# --------------------------------------------------
## libs
# --------------------------------------------------
def version() -> str
# This returns standard library version
# (Note: this is hardcoded)


# --------------------------------------------------
## libs.argparse
# --------------------------------------------------
ARGPARSE_DEFAULT: Const[int]
# Default behaviour of argparse
ARGPARSE_IGNORE_UNKNOWN_ARGS: Const[int]
# Ignore unknown arguments
ARGPARSE_STOP_AT_NON_AND_IGNORE_UNKNWON: Const[int]
# Do both stopping at unknown options and ignoring unknown arguments
ARGPARSE_STOP_AT_NON_OPTION: Const[int]
# Stop at non option
class ArgParse
# Arg parse state object
class ArgParseRemainder
# Remaining arguments after parsing given arguments: 
    argc: int
    remainder: Array[str]
class ArgParseWrapper
# Argument parser wrapper: 
    state: ArgParse
class Option
# An argparse option
# These objects are deleted when del_argparse() is called
# However, Array[Option] is not
def del_argparse(object: ArgParseWrapper) -> None
# Delete arg parser
def del_remainder(a: ArgParseRemainder) -> None
# Delete given argparse remainder object
def new(options: Array[Option], usages: Array[str]) -> ArgParseWrapper
# Initialize a new argument parser
# Note: options array last element must be opt_end()
def new_ex(options: Array[Option], usages: Array[str], flag: int) -> ArgParseWrapper
# Initialize a new argument parser (with flags)
# Note: options array last element must be opt_end()
def opt_boolean(short: str, large: str, result: Ptr[int], help: str) -> Option
# create a boolean option
def opt_end() -> Option
# End of options
def opt_float(short: str, large: str, result: Ptr[f32], help: str) -> Option
# create a float option
def opt_group(name: str) -> Option
# Create a command group here
def opt_help() -> Option
# Help option
def opt_integer(short: str, large: str, result: Ptr[int], help: str) -> Option
# create an integer option
def opt_string(short: str, large: str, result: Ptr[libs.c.CStr], help: str) -> Option
# create a boolean option
def parse(argp: ArgParse, arguments: Array[str]) -> ArgParseRemainder
# Parse given arguments with given argparser object
# Any remaining values are returned
# You need to delete the remainder with del_argparse_remainder()
def set_description(argp: ArgParse, description: str, epilog: str) -> None
# Set description for help message
def usage(argp: ArgParse) -> None
# Disaplay usage


# --------------------------------------------------
## libs.c
# --------------------------------------------------
macro char!
# c.char!{"a"} --> create a char --> inlinec("Const[Char]", "'a'")
macro const_str!
# c.const_str!{"Hi"} --> create a const char * const --> inlinec("Const[Ptr[Const[Char]]]", "\"Hi\"")
macro cstr!
# c.cstr!{"Hi"} --> create a c.CStr
class CBool
class CChar
class CDouble
class CFloat
class CInt
class CLong
class CLongLong
class CSChar
class CShort
class CStr
# A char* string
class CUChar
class CUInt
class CULong
class CULongLong
class CUShort
class Size
# size_t in C code
class VoidPtr
# Any pointer type
# void* in C
def acos(x: CDouble) -> CDouble
def asin(x: CDouble) -> CDouble
def atan(x: CDouble) -> CDouble
def atan2(x: CDouble, y: CDouble) -> CDouble
def calloc(n: Size, size: Size) -> VoidPtr
def ceil(x: CDouble) -> CDouble
def cos(x: CDouble) -> CDouble
def cosh(x: CDouble) -> CDouble
def cstrlen(s: CStr) -> Size
def fabs(x: CDouble) -> CDouble
def floor(x: CDouble) -> CDouble
def fmod(x: CDouble, y: CDouble) -> CDouble
def free(ptr: VoidPtr) -> None
def has_command_processor() -> bool
# Can we run system commands?
def itosize(i: int) -> Size
def log(x: CDouble) -> CDouble
def log10(x: CDouble) -> CDouble
def log2(x: CDouble) -> CDouble
def malloc(size: Size) -> VoidPtr
def memcmp(str1: VoidPtr, str2: VoidPtr, size: Size) -> CInt
def memcpy(dest: VoidPtr, src: VoidPtr, size: Size) -> VoidPtr
def memmove(dest: VoidPtr, src: VoidPtr, size: Size) -> VoidPtr
def memset(dest: VoidPtr, character: CInt, size: Size) -> VoidPtr
def pow(x: CDouble, y: CDouble) -> CDouble
def realloc(ptr: VoidPtr, size: Size) -> VoidPtr
def sin(x: CDouble) -> CDouble
def sinh(x: CDouble) -> CDouble
def sqrt(x: CDouble) -> CDouble
def system(program: CStr) -> None
# Run a system command without caring what it will do
# Wait for exit
def tan(x: CDouble) -> CDouble
def tanh(x: CDouble) -> CDouble


# --------------------------------------------------
## libs.console
# --------------------------------------------------
BLUE: Const[int]
# Apply blue foreground color
CYAN: Const[int]
# Apply cyan foreground color
GREEN: Const[int]
# Apply green foreground color
PURPLE: Const[int]
# Apply purple foreground color
RED: Const[int]
# Apply red foreground color
REWIND: Const[int]
# Use rewind with set_color to stop applying any color
WHITE: Const[int]
# Apply white foreground color
YELLOW: Const[int]
# Apply yellow foreground color
def blue(x: sr) -> None
# Print text in console, in blue color
def clear() -> None
# Clear console
def color_print(color: int, x: sr) -> None
# Print in given color and then rewind
def cyan(x: sr) -> None
# Print text in console, in cyan color
def getch() -> int
# Get a single character / key press
#   Can be used as a pause
def green(x: sr) -> None
# Print text in console, in green color
def purple(x: sr) -> None
# Print text in console, in purple color
def red(x: sr) -> None
# Print text in console, in red color
def set_color(c: int) -> None
# Set given color
def white(x: sr) -> None
# Print text in console, in white color
def yellow(x: sr) -> None
# Print text in console, in yellow color


# --------------------------------------------------
## libs.fileformats.ini
# --------------------------------------------------
class Ini
# INI Object
def del_ini(object: Ini) -> None
# Delete INI object
def from_str(ini_data: sr) -> Ini
# Parse INI file from given string data
def get(object: Ini, section: sr, property: sr) -> str
# Get a property in given section
# Empty string is returned if we cannot find the section


# --------------------------------------------------
## libs.fileformats.toml
# --------------------------------------------------
class Table
# TOML Table object
# This is like a dictionary
class TomlArray
# Array of any type
def array_len(x: TomlArray) -> int
# Get length of array
def bool_at(x: TomlArray, pos: int) -> bool
# Get bool from array at location or false
def bool_at_default(x: TomlArray, pos: int, default: bool) -> bool
# Get bool from array at location or given default
def del_table(x: Table) -> None
# Delete a table. Note that you do not need to delete child tables
def from_str(x: sr) -> Table
# Parse to a TOML Table from given string
def get_array(x: Table, name: sr) -> TomlArray
# Get any array from table object
def get_bool(x: Table, name: sr) -> bool
# Get a bool from table or false if fails
def get_bool_default(x: Table, name: sr, default: bool) -> bool
# Get a bool from table or given default
def get_int(x: Table, name: sr) -> int
# Get an int from table or 0 if fails
def get_int_default(x: Table, name: sr, default: int) -> int
# Get an int from table or given default
def get_string(x: Table, name: sr) -> str
# Get a string from table or empty if fails
def get_string_array(x: Table, name: sr) -> Array[str]
# Get an array as native string array
def get_string_default(x: Table, name: sr, default: sr) -> str
# Get a string from table or given default
def get_table(x: Table, name: sr) -> Table
# Get a Table from given name
def int_at(x: TomlArray, pos: int) -> int
# Get int from array at location or 0
def int_at_default(x: TomlArray, pos: int, default: int) -> int
# Get int from array at locaiton or given default
def string_at(x: TomlArray, pos: int) -> str
# Get string from array at location or empty
def string_at_default(x: TomlArray, pos: int, default: sr) -> str
# Get string from array at location or given default
def valid_array(x: TomlArray) -> bool
# Is this a valid array?
def valid_table(x: Table) -> bool
# Is this a valid table?


# --------------------------------------------------
## libs.io
# --------------------------------------------------
MAP_ANON: Const[int]
MAP_ANONYMOUS: Const[int]
MAP_FAILED: Const[int]
MAP_FILE: Const[int]
MAP_FIXED: Const[int]
MAP_PRIVATE: Const[int]
MAP_SHARED: Const[int]
MAP_TYPE: Const[int]
MS_ASYNC: Const[int]
MS_INVALIDATE: Const[int]
MS_SYNC: Const[int]
O_APPEND: Const[int]
O_ASYNC: Const[int]
O_CLOEXEC: Const[int]
O_CREAT: Const[int]
O_EXCL: Const[int]
O_NONBLOCK: Const[int]
O_RDONLY: Const[int]
O_RDWR: Const[int]
O_TMPFILE: Const[int]
O_WRONLY: Const[int]
PROT_EXEC: Const[int]
PROT_NONE: Const[int]
PROT_READ: Const[int]
PROT_WRITE: Const[int]
class File
class FilePos
def clear_error(stream: Ptr[File]) -> None
# Clear eof and error
def close(file: libs.c.CInt) -> bool
def fclose(stream: Ptr[File]) -> bool
# Close a file using given FILE*
def fflush(stream: Ptr[File]) -> bool
def fflush_all() -> bool
def fopen(fname: str, mode: str) -> Ptr[File]
# Open a file
def fread(buffer: AnyPtr, size: libs.c.Size, count: libs.c.Size, stream: Ptr[File]) -> libs.c.Size
def fseek_begin(stream: Ptr[File], offset: i64) -> bool
# Seek from begining
def fseek_end(stream: Ptr[File], offset: i64) -> bool
# Seek from end
def fseek_relative(stream: Ptr[File], offset: i64) -> bool
# Seem from current location
def ftell(stream: Ptr[File]) -> i64
def fwrite(buffer: AnyPtr, size: libs.c.Size, count: libs.c.Size, stream: Ptr[File]) -> libs.c.Size
def has_error(stream: Ptr[File]) -> bool
# Has error?
def is_eof(stream: Ptr[File]) -> bool
# Is end of file?
def mlock(address: AnyPtr, length: libs.c.Size) -> int
def mmap(address: AnyPtr, length: libs.c.Size, protection: int, flags: int, file_descriptor: libs.c.CInt, offset: i64) -> AnyPtr
def mprotect(address: AnyPtr, length: libs.c.Size, protection: int) -> int
def msync(address: AnyPtr, length: libs.c.Size, flags: int) -> int
def munlock(address: AnyPtr, length: libs.c.Size) -> int
def munmap(address: AnyPtr, length: libs.c.Size) -> int
def open(path: str, mode: int) -> libs.c.CInt
def readfile(fname: str) -> str
# Read a file to as string, on error returns empty
def rewind(stream: Ptr[File]) -> None
# Set the position as begining of file
def stderr() -> Ptr[File]
def stdin() -> Ptr[File]
def stdout() -> Ptr[File]
def valid(stream: Ptr[File]) -> bool
# Did we succesfully opened a file?
def writefile(fname: str, data: str) -> bool
# Write a file


# --------------------------------------------------
## libs.numbers
# --------------------------------------------------
def cdbl2d(a: libs.c.CDouble) -> f64
# c.CDouble to f64 (double precision)
def cstr2i(a: libs.c.CStr) -> int
# Convert a c-string to an integer
def d2cdbl(a: f64) -> libs.c.CDouble
# f64 (double precision) to c.CDouble
def d2f(a: f64) -> float
# f64 (double precision) to float/f32 (single precision)
# Warning: precision might be lost/truncated
def d2i(a: f64) -> int
# f64 (double precision) to int/i32
# Warning: value is truncated
def d2uu(a: f64) -> u64
def f2d(a: float) -> f64
# float/f32 (single precision) to f64 (double precision)
def f2i(a: float) -> int
# f32 (single precision) to int/i32
# Warning: value is truncated
def f2uu(a: float) -> u64
def from_be16(a: u16) -> u16
def from_be32(a: u32) -> u32
def from_be64(a: u64) -> u64
def from_le16(a: u16) -> u16
def from_le32(a: u32) -> u32
def from_le64(a: u64) -> u64
def i2d(a: int) -> f64
# int/i32 to f64 (double precision)
def i2f(a: int) -> float
# int/i32 to f32 (single precision)
def i2s(a: int) -> str
def i2u(a: int) -> u32
def i2uu(a: int) -> u64
def s2i(s: str) -> int
# Convert a str to integer
def swap_16(a: u16) -> u16
def swap_32(a: u32) -> u32
def swap_64(a: u64) -> u64
def to_be16(a: u16) -> u16
def to_be32(a: u32) -> u32
def to_be64(a: u64) -> u64
def to_le16(a: u16) -> u16
def to_le32(a: u32) -> u32
def to_le64(a: u64) -> u64
def u2i(a: u32) -> int
def uu2d(a: u64) -> f64
def uu2f(a: u64) -> float
def uu2i(a: u64) -> int


# --------------------------------------------------
## libs.os
# --------------------------------------------------
class Arguments
# UTF-8 converted arguments and argument count
# Do not delete, Do not modify: 
    argc: int
    argv: Array[str]
class ProcessResult
# Results of run() execution
#   Must be deleted: 
    ok: bool
    output: str
    return_code: int
def chdir(path: str) -> bool
# Change current working directory
def cwd() -> str
# Get current working directory, or empty string (if failed) on return
def del_process_result(pr: ProcessResult) -> None
# Delete process result object
def exe() -> str
# Get exe file path, or empty string (if failed) on return
def exe_path() -> str
# Get exe directory path, or empty string (if failed) on return
def get_args() -> Arguments
# Get arguments
def getenv(name: str) -> str
# Get environment variable, empty if not found or error
def is_macos() -> bool
# Are we running MacOS?
def is_windows() -> bool
# Are we running Windows?
def run(args: Array[str]) -> ProcessResult
# Run give [process, arg1, arg2] command line
def which(binary: str) -> str
# Try to find full path to binary in $PATH, no need .exe for windows
# If we cannot find in $PATH, This will fallback to current path and exe path as well
#
# Example find zig compiler path:
#
# os.which("zig")


# --------------------------------------------------
## libs.os.cpu
# --------------------------------------------------
class Cpu
# Extracted CPU information: 
    n_processors: int
    n_processors_max: int
    is_guess: bool
def info() -> Cpu
# Extract CPU information


# --------------------------------------------------
## libs.os.path
# --------------------------------------------------
def basename(p: str) -> str
# Get just the filename of given path
def dirname(p: str) -> str
# Get dir name of given path
def end_with_dot(a: sr) -> bool
# Does the given string end with slash?
def end_with_slash(a: sr) -> bool
# Does the given string end with slash?
def executable(p: str) -> bool
# Is an executable?
def exists(p: str) -> bool
# Does the file exist?
def forward_slash() -> bool
# Are we using forward slash or not?
# Same as using libs.os.is_windows()
def join(a: sr, b: sr) -> str
# Do a path join
def mkdir(p: str) -> bool
# Create given folder. (Linux uses 0755 permissions)
# Returns True if successful
def readable(p: str) -> bool
# Is a readable?
def remove_extension(p: str) -> str
# Remove extension
def writable(p: str) -> bool
# Is a writable?


# --------------------------------------------------
## libs.perlin
# --------------------------------------------------
def noise1d(x: f64) -> f64
# Get perlin noise in 1d (Calls 3d noise with hardcoded y, z values)
def noise1df(x: float) -> float
def noise2d(x: f64, y: f64) -> f64
# Get perlin noise in 2d
def noise2df(x: float, y: float) -> float
# Get perlin noise in 2d
def noise3d(x: f64, y: f64, z: f64) -> f64
# Get perlin noise in 3d
def noise3df(x: float, y: float, z: float) -> float
# Get perlin noise in 3d


# --------------------------------------------------
## libs.random
# --------------------------------------------------
def init_random() -> u64
# Set a seed to random number generator using time (crypto unsafe)
def random() -> f64
# Get a random value between 0 - 1 (crypto unsafe)
def random_between(a: f64, b: f64) -> f64
# Get a random value between a and b (crypto unsafe)
def random_betweenf(a: float, b: float) -> float
# Get a random value between a and b (crypto unsafe)
def random_u64() -> u64
# Random unsigned 64bit
# Uses rand() (crypto unsafe)
def randomf() -> float
# Get a random value between 0 - 1 (crypto unsafe)
def set_seed(seed: u64) -> None
# Set a seed to random number generator (crypto unsafe)


# --------------------------------------------------
## libs.strings
# --------------------------------------------------
def contains(haystack: str, needle: str) -> bool
# Does the string needle contain in string haystack?
def cut_from(a: str, position: int) -> str
# Cut a string from given position
def del_cstr(a: libs.c.CStr) -> None
# Delete a native c-string created from other other functions (calls free)
def del_str(a: libs.c.CStr) -> None
# Delete a normal string that was cast as a c-str with to_cstr
# You only need to use this if CStr was cast from standard str
def endswith(a: str, b: str) -> bool
# Does string a ends with string b
def find_char(value: str, ch: int) -> int
# Find first occurance of given character
def from_cstr(a: libs.c.CStr) -> str
# Create a string from CStr
def from_cstrlen(a: libs.c.CStr, length: int) -> str
# Create a string from CStr with a given length
def from_cstrlen_after(a: libs.c.CStr, length: int, after: int) -> str
# Create a new string from CStr from given after location for given length
def get(s: str, pos: int) -> int
# Get a single byte from given string and position
# Warning: Does not do a length check
# Warning: This copies the string to just get a single byte
def get_cstr(s: libs.c.CStr, pos: int) -> int
# Get a single byte from given CStr
# Warning: Does not do a length check
def isempty(s: str) -> bool
# Is this string empty?
def isempty_cstr(s: libs.c.CStr) -> bool
# Is an empty CStr?
def lpad(a: str, count: int) -> str
# Pad string to left to ensure string length is large or equal to count
def mid(a: str, position: int, number: int) -> str
# Cut a string from given position for number characters
# Returns empty() if input is invalid
def null_cstr() -> libs.c.CStr
def ord(s: str) -> int
# Get first byte of string
def ord_cstr(s: libs.c.CStr) -> int
# Get first byte of CStr
def rpad(a: str, count: int) -> str
# Pad string to right to ensure string length is large or equal to count
def set_cstr(s: libs.c.CStr, pos: int, v: int) -> None
# Set a byte to given CStr position
# Warning: Does not do a length check
def spaces(count: int) -> str
# Get a spaces only string of given count
def split(value: str, sep: str) -> Array[str]
# Split a string to a string array
def startswith(a: str, b: str) -> bool
# Does the given string a starts with b
def to_cstr(a: str) -> libs.c.CStr
# Yaksha copies managed strings that you pass in so must free this
def valid_cstr(s: libs.c.CStr) -> bool
# Is a valid CStr


# --------------------------------------------------
## libs.strings.array
# --------------------------------------------------
def del_str_array(sa: Array[str]) -> None
# Delete a string array by deleting individual string objects and array itself
def dup(sa: Array[str]) -> Array[str]
# Duplicate given array to a new array
# Both new array and string copies are created
def extend(a: Array[str], b: Array[str]) -> Array[str]
# Copy all strings from b to a and return a
# Warning! You must assign this back to a (as 'a' might be reallocated to a new address)
def join(values: Array[str], sep: str) -> str
# Join given string array with given separator and return a single string
def new(count: int, s: str) -> Array[str]
# Create new string array
# Example:
#
# import libs.strings.array as sarr
# my_array: Array[str] = sarr.new(4, "A", "B", "C", "D")
def prefix(sa: Array[str], prefix_str: str) -> Array[str]
# Mutate all strings in this array by prefixing with prefix_str
def suffix(sa: Array[str], suffix_str: str) -> Array[str]
# Mutate all strings in this array by suffixing with suffix_str


# --------------------------------------------------
## libs.strings.buffer
# --------------------------------------------------
class StringBuffer
# String buffer object
def append(buf: StringBuffer, v: sr) -> None
# Append a string to string buffer
def del_buf(buf: StringBuffer) -> None
# Delete string buffer object
def join(buf: StringBuffer, values: Array[str], sep: sr) -> None
# Join given values in array with provided seperator and append this to string
def join_sr(buf: StringBuffer, values: Array[sr], sep: sr) -> None
# Join given values in array with provided seperator and append this to string buffer
def new() -> StringBuffer
# Create a new empty string buffer
def new_size(s: int) -> StringBuffer
# Create a string buffer with capacity s
def prepend(buf: StringBuffer, v: sr) -> None
# Prepend a string to string buffer
def to_sr(buf: StringBuffer) -> sr
# Get a string reference out of string buffer
def to_str(buf: StringBuffer) -> str
# Get a new string copy out of string buffer


# --------------------------------------------------
## libs.strings.refs
# --------------------------------------------------
def unwrap(a: sr) -> Const[libs.c.CStr]
# Get internal string reference from sr
def wrap(s: sr) -> sr
# Wrap a str/literal/sr (if a sr is passed in reference is not wrapped again) as sr
# This takes advantage of the auto-casting
def wrap_cstr(s: libs.c.CStr, length: int) -> sr
# Wrap a c.CStr as a sr
def wrap_cstr_z(s: libs.c.CStr) -> sr


# --------------------------------------------------
## libs.strings.utf8
# --------------------------------------------------
class Utf8IterateState
# Iterator state for UTF-8 iteration
# See the codepoint for current character: 
    step_size: int
    codepoint: int
def del_iter(s: Utf8IterateState) -> None
# Delete the iterator object after done
def iterate(s: Utf8IterateState) -> bool
# Go to next character
# Returns false if nothing to read or we ran out of length of string
def new_iter(s: sr) -> Utf8IterateState
# Create a new iterator from given string


# --------------------------------------------------
## libs.thread
# --------------------------------------------------
BUSY: Const[int]
# The requested operation failed because a tesource requested by a test and return function is already in use
ERROR: Const[int]
# The requested operation failed
NOMEM: Const[int]
# The requested operation failed because it was unable to allocate memory
SLEEP_SUCCES: Const[int]
# Sleep is successful
SUCCESS: Const[int]
# The requested operation succeeded
TIMEOUT: Const[int]
# The time specified in the call was reached without acquiring the requested resource
class Thread
# Thread Object
def create(thr: Ptr[Thread], func: Function[In[AnyPtr], Out[int]]) -> int
# Create a thread with None data. Otherwise same as create_with_data()
def create_with_data(thr: Ptr[Thread], func: Function[In[AnyPtr], Out[int]], data: AnyPtr) -> int
# Create a new thread with given reference to Thread and a function that takes AnyPtr and return int
def current() -> Thread
# Get current thread object
def detach(thr: Thread) -> int
def equal(thr1: Thread, thr2: Thread) -> int
# Are these two equal?
def exit(res: int) -> None
# Exit current thread giving result value
def join(thr: Thread) -> int
def join_with_result(thr: Thread, res: Ptr[int]) -> int
def sleep(seconds: int) -> int
# Sleep for given seconds
# SLEEP_SUCCES is returned if successful
def sleep_ex(duration: Ptr[libs.timespec.TimeSpec], remainder: Ptr[libs.timespec.TimeSpec]) -> int
# remainder - this parameter will hold the remaining time until time_point upon return
# SLEEP_SUCCES is returned if successful
def yield() -> None


# --------------------------------------------------
## libs.thread.condition
# --------------------------------------------------
class Condition
# Condition Object
def broadcast(cnd: Ptr[Condition]) -> int
def destroy(cnd: Ptr[Condition]) -> None
def init(cnd: Ptr[Condition]) -> int
def signal(cnd: Ptr[Condition]) -> int
def timed_wait(cnd: Ptr[Condition], mtx: Ptr[libs.thread.mutex.Mutex], ts: Ptr[libs.timespec.TimeSpec]) -> int
def wait(cnd: Ptr[Condition], mtx: Ptr[libs.thread.mutex.Mutex]) -> int


# --------------------------------------------------
## libs.thread.mutex
# --------------------------------------------------
PLAIN: Const[int]
RECURSIVE: Const[int]
TIMED: Const[int]
class Mutex
# Mutex Object
def destroy(mtx: Ptr[Mutex]) -> None
def init(mtx: Ptr[Mutex], type: int) -> int
def lock(mtx: Ptr[Mutex]) -> int
def trylock(mtx: Ptr[Mutex]) -> int
def unlock(mtx: Ptr[Mutex]) -> int


# --------------------------------------------------
## libs.thread.pool
# --------------------------------------------------
ERROR_INVALID: Const[int]
ERROR_LOCK_FAILURE: Const[int]
ERROR_QUEUE_FULL: Const[int]
ERROR_SHUTDOWN: Const[int]
ERROR_THREAD_FAILURE: Const[int]
GRACEFUL_SHUTDOWN: Const[int]
# We are waiting for tasks to be completed
IMMEDIATE_SHUTDOWN: Const[int]
# Default (shutdown all threads forcefully) and close the pool
MAX_QUEUE_SIZE: Const[u32]
# Maximum queue size for thread pool
MAX_THREAD_SIZE: Const[u8]
# Maximum threads we can create is 64
NO_SHUTDOWN: Const[int]
# Not going to shutdown
SUCCESS: Const[int]
class ThreadPool
# Thread pool object: 
    lock: libs.thread.mutex.Mutex
    notify: libs.thread.condition.Condition
    threads: Array[libs.thread.Thread]
    queue: Array[Tuple[Function[In[AnyPtr], Out], AnyPtr]]
    thread_count: int
    queue_size: int
    head: int
    tail: int
    count: int
    shutdown: int
    started: int
def add(tpool: ThreadPool, func: Function[In[AnyPtr], Out], arg: AnyPtr) -> int
# Add given task to the thread pool to be executed
# returns SUCCESS if successful
def create(thread_count: u8, queue_size: u32) -> ThreadPool
# Create a new thread pool with given thread count and queue size
# On success ThreadPool is returned else, it should be equal to None
def destroy(tpool: ThreadPool, graceful: bool) -> int
# Attempt to destroy thread pool, if SUCCESS is returned pool is deallocated as well
def internal_del_pool(tpool: ThreadPool) -> int
# Clean up thread pool data
def internal_tpool_work(tpool_obj: AnyPtr) -> int
# Perform work as a thread in the managed thread pool


# --------------------------------------------------
## libs.thread.tss
# --------------------------------------------------
class Key
# Key to access/create thread specific storage
# Declare a variable and use with getref() when calling create()
def create(key: Ptr[Key]) -> int
# Create with no auto deletion
def create_with_deleter(key: Ptr[Key], deleter: Function[In[AnyPtr], Out]) -> int
# Create TSS with a custom deleter function
def del_data(key: Key) -> None
def get(key: Key) -> AnyPtr
def set(key: Key, data: AnyPtr) -> int


# --------------------------------------------------
## libs.timespec
# --------------------------------------------------
class TimeSpec
def add_nanoseconds(a: Ptr[TimeSpec], n: i64) -> None
def add_seconds(a: Ptr[TimeSpec], n: int) -> None
def compare_ex(a: Ptr[TimeSpec], b: Ptr[TimeSpec]) -> i64
def create() -> TimeSpec
def create_ex(seconds: int) -> TimeSpec
def equal(a: TimeSpec, b: TimeSpec) -> bool
# is a == b
def get_nanoseconds(t: TimeSpec) -> i64
def get_seconds(t: TimeSpec) -> int
def get_utc_now(t: Ptr[TimeSpec]) -> bool
# Load UTC now into given pointer
# If successful True is returned
def greater(a: TimeSpec, b: TimeSpec) -> bool
# is a > b ?
def in_future(seconds: int) -> TimeSpec
def in_future_ex(seconds: int, nanoseconds: i64) -> TimeSpec
def lessser(a: TimeSpec, b: TimeSpec) -> bool
# is a < b ?
def now() -> TimeSpec


# --------------------------------------------------
## libs.unittest
# --------------------------------------------------
macro assert_false!
# unittest.assert_false!{"description" x} - assert that this is false
macro assert_true!
# unittest.assert_true!{"description" x} - assert that this is true
macro end_test_case!
# see unittest.test_case example above
macro run_all!
# unittest.run_all!{} - put this at the end to run all unit tests you created
macro test_case!
# unittest.test_case!{"name"}: - start a test case definition
#
# # --- Ensure you use below imports as is ---
#
# import libs.unittest as u
# import libs.console as console
#
# u.test_case!{"assumptions"}:
#     u.assert_true!{"char is 1 byte" (1 == inlinec("int", "sizeof(char)"))}
#     x = 1
#     u.assert_true!{"int is 4 byte" (4 == inlinec("int", "sizeof(yy__x)"))}
#     u.end_test_case!{}
#
# u.run_all!{}


# --------------------------------------------------
## raylib
# --------------------------------------------------
BLEND_ADDITIVE: Const[int]
# Blend textures adding colors
BLEND_ADD_COLORS: Const[int]
# Blend textures adding colors (alternative)
BLEND_ALPHA: Const[int]
# Blend textures considering alpha (default)
BLEND_ALPHA_PREMULTIPLY: Const[int]
# Blend premultiplied textures considering alpha
BLEND_CUSTOM: Const[int]
# Blend textures using custom src/dst factors (use rlSetBlendFactors())
BLEND_CUSTOM_SEPARATE: Const[int]
# Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())
BLEND_MULTIPLIED: Const[int]
# Blend textures multiplying colors
BLEND_SUBTRACT_COLORS: Const[int]
# Blend textures subtracting colors (alternative)
CAMERA_CUSTOM: Const[int]
# Custom camera
CAMERA_FIRST_PERSON: Const[int]
# First person camera
CAMERA_FREE: Const[int]
# Free camera
CAMERA_ORBITAL: Const[int]
# Orbital camera
CAMERA_ORTHOGRAPHIC: Const[int]
# Orthographic projection
CAMERA_PERSPECTIVE: Const[int]
# Perspective projection
CAMERA_THIRD_PERSON: Const[int]
# Third person camera
CUBEMAP_LAYOUT_AUTO_DETECT: Const[int]
# Automatically detect layout type
CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE: Const[int]
# Layout is defined by a 4x3 cross with cubemap faces
CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR: Const[int]
# Layout is defined by a 3x4 cross with cubemap faces
CUBEMAP_LAYOUT_LINE_HORIZONTAL: Const[int]
# Layout is defined by a horizontal line with faces
CUBEMAP_LAYOUT_LINE_VERTICAL: Const[int]
# Layout is defined by a vertical line with faces
CUBEMAP_LAYOUT_PANORAMA: Const[int]
# Layout is defined by a panorama image (equirrectangular map)
FLAG_FULLSCREEN_MODE: Const[int]
# Set to run program in fullscreen
FLAG_INTERLACED_HINT: Const[int]
# Set to try enabling interlaced video format (for V3D)
FLAG_MSAA_4X_HINT: Const[int]
# Set to try enabling MSAA 4X
FLAG_VSYNC_HINT: Const[int]
# Set to try enabling V-Sync on GPU
FLAG_WINDOW_ALWAYS_RUN: Const[int]
# Set to allow windows running while minimized
FLAG_WINDOW_HIDDEN: Const[int]
# Set to hide window
FLAG_WINDOW_HIGHDPI: Const[int]
# Set to support HighDPI
FLAG_WINDOW_MAXIMIZED: Const[int]
# Set to maximize window (expanded to monitor)
FLAG_WINDOW_MINIMIZED: Const[int]
# Set to minimize window (iconify)
FLAG_WINDOW_MOUSE_PASSTHROUGH: Const[int]
# Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
FLAG_WINDOW_RESIZABLE: Const[int]
# Set to allow resizable window
FLAG_WINDOW_TOPMOST: Const[int]
# Set to window always on top
FLAG_WINDOW_TRANSPARENT: Const[int]
# Set to allow transparent framebuffer
FLAG_WINDOW_UNDECORATED: Const[int]
# Set to disable window decoration (frame and buttons)
FLAG_WINDOW_UNFOCUSED: Const[int]
# Set to window non focused
FONT_BITMAP: Const[int]
# Bitmap font generation, no anti-aliasing
FONT_DEFAULT: Const[int]
# Default font generation, anti-aliased
FONT_SDF: Const[int]
# SDF font generation, requires external shader
GAMEPAD_AXIS_LEFT_TRIGGER: Const[int]
# Gamepad back trigger left, pressure level: [1..-1]
GAMEPAD_AXIS_LEFT_X: Const[int]
# Gamepad left stick X axis
GAMEPAD_AXIS_LEFT_Y: Const[int]
# Gamepad left stick Y axis
GAMEPAD_AXIS_RIGHT_TRIGGER: Const[int]
# Gamepad back trigger right, pressure level: [1..-1]
GAMEPAD_AXIS_RIGHT_X: Const[int]
# Gamepad right stick X axis
GAMEPAD_AXIS_RIGHT_Y: Const[int]
# Gamepad right stick Y axis
GAMEPAD_BUTTON_LEFT_FACE_DOWN: Const[int]
# Gamepad left DPAD down button
GAMEPAD_BUTTON_LEFT_FACE_LEFT: Const[int]
# Gamepad left DPAD left button
GAMEPAD_BUTTON_LEFT_FACE_RIGHT: Const[int]
# Gamepad left DPAD right button
GAMEPAD_BUTTON_LEFT_FACE_UP: Const[int]
# Gamepad left DPAD up button
GAMEPAD_BUTTON_LEFT_THUMB: Const[int]
# Gamepad joystick pressed button left
GAMEPAD_BUTTON_LEFT_TRIGGER_1: Const[int]
# Gamepad top/back trigger left (first), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_2: Const[int]
# Gamepad top/back trigger left (second), it could be a trailing button
GAMEPAD_BUTTON_MIDDLE: Const[int]
# Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
GAMEPAD_BUTTON_MIDDLE_LEFT: Const[int]
# Gamepad center buttons, left one (i.e. PS3: Select)
GAMEPAD_BUTTON_MIDDLE_RIGHT: Const[int]
# Gamepad center buttons, right one (i.e. PS3: Start)
GAMEPAD_BUTTON_RIGHT_FACE_DOWN: Const[int]
# Gamepad right button down (i.e. PS3: Cross, Xbox: A)
GAMEPAD_BUTTON_RIGHT_FACE_LEFT: Const[int]
# Gamepad right button left (i.e. PS3: Circle, Xbox: B)
GAMEPAD_BUTTON_RIGHT_FACE_RIGHT: Const[int]
# Gamepad right button right (i.e. PS3: Square, Xbox: X)
GAMEPAD_BUTTON_RIGHT_FACE_UP: Const[int]
# Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
GAMEPAD_BUTTON_RIGHT_THUMB: Const[int]
# Gamepad joystick pressed button right
GAMEPAD_BUTTON_RIGHT_TRIGGER_1: Const[int]
# Gamepad top/back trigger right (one), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_2: Const[int]
# Gamepad top/back trigger right (second), it could be a trailing button
GAMEPAD_BUTTON_UNKNOWN: Const[int]
# Unknown button, just for error checking
GESTURE_DOUBLETAP: Const[int]
# Double tap gesture
GESTURE_DRAG: Const[int]
# Drag gesture
GESTURE_HOLD: Const[int]
# Hold gesture
GESTURE_NONE: Const[int]
# No gesture
GESTURE_PINCH_IN: Const[int]
# Pinch in gesture
GESTURE_PINCH_OUT: Const[int]
# Pinch out gesture
GESTURE_SWIPE_DOWN: Const[int]
# Swipe down gesture
GESTURE_SWIPE_LEFT: Const[int]
# Swipe left gesture
GESTURE_SWIPE_RIGHT: Const[int]
# Swipe right gesture
GESTURE_SWIPE_UP: Const[int]
# Swipe up gesture
GESTURE_TAP: Const[int]
# Tap gesture
KEY_A: Const[int]
# Key: A | a
KEY_APOSTROPHE: Const[int]
# Key: '
KEY_B: Const[int]
# Key: B | b
KEY_BACK: Const[int]
# Key: Android back button
KEY_BACKSLASH: Const[int]
# Key: '\'
KEY_BACKSPACE: Const[int]
# Key: Backspace
KEY_C: Const[int]
# Key: C | c
KEY_CAPS_LOCK: Const[int]
# Key: Caps lock
KEY_COMMA: Const[int]
# Key: ,
KEY_D: Const[int]
# Key: D | d
KEY_DELETE: Const[int]
# Key: Del
KEY_DOWN: Const[int]
# Key: Cursor down
KEY_E: Const[int]
# Key: E | e
KEY_EIGHT: Const[int]
# Key: 8
KEY_END: Const[int]
# Key: End
KEY_ENTER: Const[int]
# Key: Enter
KEY_EQUAL: Const[int]
# Key: =
KEY_ESCAPE: Const[int]
# Key: Esc
KEY_F: Const[int]
# Key: F | f
KEY_F1: Const[int]
# Key: F1
KEY_F10: Const[int]
# Key: F10
KEY_F11: Const[int]
# Key: F11
KEY_F12: Const[int]
# Key: F12
KEY_F2: Const[int]
# Key: F2
KEY_F3: Const[int]
# Key: F3
KEY_F4: Const[int]
# Key: F4
KEY_F5: Const[int]
# Key: F5
KEY_F6: Const[int]
# Key: F6
KEY_F7: Const[int]
# Key: F7
KEY_F8: Const[int]
# Key: F8
KEY_F9: Const[int]
# Key: F9
KEY_FIVE: Const[int]
# Key: 5
KEY_FOUR: Const[int]
# Key: 4
KEY_G: Const[int]
# Key: G | g
KEY_GRAVE: Const[int]
# Key: `
KEY_H: Const[int]
# Key: H | h
KEY_HOME: Const[int]
# Key: Home
KEY_I: Const[int]
# Key: I | i
KEY_INSERT: Const[int]
# Key: Ins
KEY_J: Const[int]
# Key: J | j
KEY_K: Const[int]
# Key: K | k
KEY_KB_MENU: Const[int]
# Key: KB menu
KEY_KP_0: Const[int]
# Key: Keypad 0
KEY_KP_1: Const[int]
# Key: Keypad 1
KEY_KP_2: Const[int]
# Key: Keypad 2
KEY_KP_3: Const[int]
# Key: Keypad 3
KEY_KP_4: Const[int]
# Key: Keypad 4
KEY_KP_5: Const[int]
# Key: Keypad 5
KEY_KP_6: Const[int]
# Key: Keypad 6
KEY_KP_7: Const[int]
# Key: Keypad 7
KEY_KP_8: Const[int]
# Key: Keypad 8
KEY_KP_9: Const[int]
# Key: Keypad 9
KEY_KP_ADD: Const[int]
# Key: Keypad +
KEY_KP_DECIMAL: Const[int]
# Key: Keypad .
KEY_KP_DIVIDE: Const[int]
# Key: Keypad /
KEY_KP_ENTER: Const[int]
# Key: Keypad Enter
KEY_KP_EQUAL: Const[int]
# Key: Keypad =
KEY_KP_MULTIPLY: Const[int]
# Key: Keypad *
KEY_KP_SUBTRACT: Const[int]
# Key: Keypad -
KEY_L: Const[int]
# Key: L | l
KEY_LEFT: Const[int]
# Key: Cursor left
KEY_LEFT_ALT: Const[int]
# Key: Alt left
KEY_LEFT_BRACKET: Const[int]
# Key: [
KEY_LEFT_CONTROL: Const[int]
# Key: Control left
KEY_LEFT_SHIFT: Const[int]
# Key: Shift left
KEY_LEFT_SUPER: Const[int]
# Key: Super left
KEY_M: Const[int]
# Key: M | m
KEY_MENU: Const[int]
# Key: Android menu button
KEY_MINUS: Const[int]
# Key: -
KEY_N: Const[int]
# Key: N | n
KEY_NINE: Const[int]
# Key: 9
KEY_NULL: Const[int]
# Key: NULL, used for no key pressed
KEY_NUM_LOCK: Const[int]
# Key: Num lock
KEY_O: Const[int]
# Key: O | o
KEY_ONE: Const[int]
# Key: 1
KEY_P: Const[int]
# Key: P | p
KEY_PAGE_DOWN: Const[int]
# Key: Page down
KEY_PAGE_UP: Const[int]
# Key: Page up
KEY_PAUSE: Const[int]
# Key: Pause
KEY_PERIOD: Const[int]
# Key: .
KEY_PRINT_SCREEN: Const[int]
# Key: Print screen
KEY_Q: Const[int]
# Key: Q | q
KEY_R: Const[int]
# Key: R | r
KEY_RIGHT: Const[int]
# Key: Cursor right
KEY_RIGHT_ALT: Const[int]
# Key: Alt right
KEY_RIGHT_BRACKET: Const[int]
# Key: ]
KEY_RIGHT_CONTROL: Const[int]
# Key: Control right
KEY_RIGHT_SHIFT: Const[int]
# Key: Shift right
KEY_RIGHT_SUPER: Const[int]
# Key: Super right
KEY_S: Const[int]
# Key: S | s
KEY_SCROLL_LOCK: Const[int]
# Key: Scroll down
KEY_SEMICOLON: Const[int]
# Key: ;
KEY_SEVEN: Const[int]
# Key: 7
KEY_SIX: Const[int]
# Key: 6
KEY_SLASH: Const[int]
# Key: /
KEY_SPACE: Const[int]
# Key: Space
KEY_T: Const[int]
# Key: T | t
KEY_TAB: Const[int]
# Key: Tab
KEY_THREE: Const[int]
# Key: 3
KEY_TWO: Const[int]
# Key: 2
KEY_U: Const[int]
# Key: U | u
KEY_UP: Const[int]
# Key: Cursor up
KEY_V: Const[int]
# Key: V | v
KEY_VOLUME_DOWN: Const[int]
# Key: Android volume down button
KEY_VOLUME_UP: Const[int]
# Key: Android volume up button
KEY_W: Const[int]
# Key: W | w
KEY_X: Const[int]
# Key: X | x
KEY_Y: Const[int]
# Key: Y | y
KEY_Z: Const[int]
# Key: Z | z
KEY_ZERO: Const[int]
# Key: 0
LOG_ALL: Const[int]
# Display all logs
LOG_DEBUG: Const[int]
# Debug logging, used for internal debugging, it should be disabled on release builds
LOG_ERROR: Const[int]
# Error logging, used on unrecoverable failures
LOG_FATAL: Const[int]
# Fatal logging, used to abort program: exit(EXIT_FAILURE)
LOG_INFO: Const[int]
# Info logging, used for program execution info
LOG_NONE: Const[int]
# Disable logging
LOG_TRACE: Const[int]
# Trace logging, intended for internal use only
LOG_WARNING: Const[int]
# Warning logging, used on recoverable failures
MATERIAL_MAP_ALBEDO: Const[int]
# Albedo material (same as: MATERIAL_MAP_DIFFUSE)
MATERIAL_MAP_BRDF: Const[int]
# Brdf material
MATERIAL_MAP_CUBEMAP: Const[int]
# Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_EMISSION: Const[int]
# Emission material
MATERIAL_MAP_HEIGHT: Const[int]
# Heightmap material
MATERIAL_MAP_IRRADIANCE: Const[int]
# Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_METALNESS: Const[int]
# Metalness material (same as: MATERIAL_MAP_SPECULAR)
MATERIAL_MAP_NORMAL: Const[int]
# Normal material
MATERIAL_MAP_OCCLUSION: Const[int]
# Ambient occlusion material
MATERIAL_MAP_PREFILTER: Const[int]
# Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_ROUGHNESS: Const[int]
# Roughness material
MOUSE_BUTTON_BACK: Const[int]
# Mouse button back (advanced mouse device)
MOUSE_BUTTON_EXTRA: Const[int]
# Mouse button extra (advanced mouse device)
MOUSE_BUTTON_FORWARD: Const[int]
# Mouse button forward (advanced mouse device)
MOUSE_BUTTON_LEFT: Const[int]
# Mouse button left
MOUSE_BUTTON_MIDDLE: Const[int]
# Mouse button middle (pressed wheel)
MOUSE_BUTTON_RIGHT: Const[int]
# Mouse button right
MOUSE_BUTTON_SIDE: Const[int]
# Mouse button side (advanced mouse device)
MOUSE_CURSOR_ARROW: Const[int]
# Arrow shape
MOUSE_CURSOR_CROSSHAIR: Const[int]
# Cross shape
MOUSE_CURSOR_DEFAULT: Const[int]
# Default pointer shape
MOUSE_CURSOR_IBEAM: Const[int]
# Text writing cursor shape
MOUSE_CURSOR_NOT_ALLOWED: Const[int]
# The operation-not-allowed shape
MOUSE_CURSOR_POINTING_HAND: Const[int]
# Pointing hand cursor
MOUSE_CURSOR_RESIZE_ALL: Const[int]
# The omnidirectional resize/move cursor shape
MOUSE_CURSOR_RESIZE_EW: Const[int]
# Horizontal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NESW: Const[int]
# The top-right to bottom-left diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NS: Const[int]
# Vertical resize/move arrow shape
MOUSE_CURSOR_RESIZE_NWSE: Const[int]
# Top-left to bottom-right diagonal resize/move arrow shape
NPATCH_NINE_PATCH: Const[int]
# Npatch layout: 3x3 tiles
NPATCH_THREE_PATCH_HORIZONTAL: Const[int]
# Npatch layout: 3x1 tiles
NPATCH_THREE_PATCH_VERTICAL: Const[int]
# Npatch layout: 1x3 tiles
PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: Const[int]
# 2 bpp
PIXELFORMAT_COMPRESSED_DXT1_RGB: Const[int]
# 4 bpp (no alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGBA: Const[int]
# 4 bpp (1 bit alpha)
PIXELFORMAT_COMPRESSED_DXT3_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_DXT5_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_ETC1_RGB: Const[int]
# 4 bpp
PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_ETC2_RGB: Const[int]
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGB: Const[int]
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGBA: Const[int]
# 4 bpp
PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: Const[int]
# 8 bit per pixel (no alpha)
PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: Const[int]
# 8*2 bpp (2 channels)
PIXELFORMAT_UNCOMPRESSED_R32: Const[int]
# 32 bpp (1 channel - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32: Const[int]
# 32*3 bpp (3 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: Const[int]
# 32*4 bpp (4 channels - float)
PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: Const[int]
# 16 bpp (4 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: Const[int]
# 16 bpp (1 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R5G6B5: Const[int]
# 16 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8: Const[int]
# 24 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: Const[int]
# 32 bpp
SHADER_ATTRIB_FLOAT: Const[int]
# Shader attribute type: float
SHADER_ATTRIB_VEC2: Const[int]
# Shader attribute type: vec2 (2 float)
SHADER_ATTRIB_VEC3: Const[int]
# Shader attribute type: vec3 (3 float)
SHADER_ATTRIB_VEC4: Const[int]
# Shader attribute type: vec4 (4 float)
SHADER_LOC_COLOR_AMBIENT: Const[int]
# Shader location: vector uniform: ambient color
SHADER_LOC_COLOR_DIFFUSE: Const[int]
# Shader location: vector uniform: diffuse color
SHADER_LOC_COLOR_SPECULAR: Const[int]
# Shader location: vector uniform: specular color
SHADER_LOC_MAP_ALBEDO: Const[int]
# Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
SHADER_LOC_MAP_BRDF: Const[int]
# Shader location: sampler2d texture: brdf
SHADER_LOC_MAP_CUBEMAP: Const[int]
# Shader location: samplerCube texture: cubemap
SHADER_LOC_MAP_EMISSION: Const[int]
# Shader location: sampler2d texture: emission
SHADER_LOC_MAP_HEIGHT: Const[int]
# Shader location: sampler2d texture: height
SHADER_LOC_MAP_IRRADIANCE: Const[int]
# Shader location: samplerCube texture: irradiance
SHADER_LOC_MAP_METALNESS: Const[int]
# Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
SHADER_LOC_MAP_NORMAL: Const[int]
# Shader location: sampler2d texture: normal
SHADER_LOC_MAP_OCCLUSION: Const[int]
# Shader location: sampler2d texture: occlusion
SHADER_LOC_MAP_PREFILTER: Const[int]
# Shader location: samplerCube texture: prefilter
SHADER_LOC_MAP_ROUGHNESS: Const[int]
# Shader location: sampler2d texture: roughness
SHADER_LOC_MATRIX_MODEL: Const[int]
# Shader location: matrix uniform: model (transform)
SHADER_LOC_MATRIX_MVP: Const[int]
# Shader location: matrix uniform: model-view-projection
SHADER_LOC_MATRIX_NORMAL: Const[int]
# Shader location: matrix uniform: normal
SHADER_LOC_MATRIX_PROJECTION: Const[int]
# Shader location: matrix uniform: projection
SHADER_LOC_MATRIX_VIEW: Const[int]
# Shader location: matrix uniform: view (camera transform)
SHADER_LOC_VECTOR_VIEW: Const[int]
# Shader location: vector uniform: view
SHADER_LOC_VERTEX_COLOR: Const[int]
# Shader location: vertex attribute: color
SHADER_LOC_VERTEX_NORMAL: Const[int]
# Shader location: vertex attribute: normal
SHADER_LOC_VERTEX_POSITION: Const[int]
# Shader location: vertex attribute: position
SHADER_LOC_VERTEX_TANGENT: Const[int]
# Shader location: vertex attribute: tangent
SHADER_LOC_VERTEX_TEXCOORD01: Const[int]
# Shader location: vertex attribute: texcoord01
SHADER_LOC_VERTEX_TEXCOORD02: Const[int]
# Shader location: vertex attribute: texcoord02
SHADER_UNIFORM_FLOAT: Const[int]
# Shader uniform type: float
SHADER_UNIFORM_INT: Const[int]
# Shader uniform type: int
SHADER_UNIFORM_IVEC2: Const[int]
# Shader uniform type: ivec2 (2 int)
SHADER_UNIFORM_IVEC3: Const[int]
# Shader uniform type: ivec3 (3 int)
SHADER_UNIFORM_IVEC4: Const[int]
# Shader uniform type: ivec4 (4 int)
SHADER_UNIFORM_SAMPLER2D: Const[int]
# Shader uniform type: sampler2d
SHADER_UNIFORM_VEC2: Const[int]
# Shader uniform type: vec2 (2 float)
SHADER_UNIFORM_VEC3: Const[int]
# Shader uniform type: vec3 (3 float)
SHADER_UNIFORM_VEC4: Const[int]
# Shader uniform type: vec4 (4 float)
TEXTURE_FILTER_ANISOTROPIC_16X: Const[int]
# Anisotropic filtering 16x
TEXTURE_FILTER_ANISOTROPIC_4X: Const[int]
# Anisotropic filtering 4x
TEXTURE_FILTER_ANISOTROPIC_8X: Const[int]
# Anisotropic filtering 8x
TEXTURE_FILTER_BILINEAR: Const[int]
# Linear filtering
TEXTURE_FILTER_POINT: Const[int]
# No filter, just pixel approximation
TEXTURE_FILTER_TRILINEAR: Const[int]
# Trilinear filtering (linear with mipmaps)
TEXTURE_WRAP_CLAMP: Const[int]
# Clamps texture to edge pixel in tiled mode
TEXTURE_WRAP_MIRROR_CLAMP: Const[int]
# Mirrors and clamps to border the texture in tiled mode
TEXTURE_WRAP_MIRROR_REPEAT: Const[int]
# Mirrors and repeats the texture in tiled mode
TEXTURE_WRAP_REPEAT: Const[int]
# Repeats texture in tiled mode
class AudioStream
# AudioStream, custom audio stream
class BoneInfo
# Bone, skeletal animation bone
class BoundingBox
# BoundingBox: 
    min: Vector3
    max: Vector3
class CChar32
class CFloat2
class CFloat4
class Camera
# Camera type fallback, defaults to Camera3D: 
    position: Vector3
    target: Vector3
    up: Vector3
    fovy: float
    projection: libs.c.CInt
class Camera2D
# Camera2D, defines position/orientation in 2d space: 
    offset: Vector2
    target: Vector2
    rotation: float
    zoom: float
class Camera3D
# Camera, defines position/orientation in 3d space: 
    position: Vector3
    target: Vector3
    up: Vector3
    fovy: float
    projection: libs.c.CInt
class Color
# Color, 4 components, R8G8B8A8 (32bit): 
    r: libs.c.CUChar
    g: libs.c.CUChar
    b: libs.c.CUChar
    a: libs.c.CUChar
class DTMatrix2
class FilePathList
# File path list
class Font
# Font, font texture and GlyphInfo array data: 
    baseSize: libs.c.CInt
    glyphCount: libs.c.CInt
    glyphPadding: libs.c.CInt
    texture: Texture2D
    recs: Ptr[Rectangle]
    glyphs: Ptr[GlyphInfo]
class GlyphInfo
# GlyphInfo, font characters glyphs info: 
    value: libs.c.CInt
    offsetX: libs.c.CInt
    offsetY: libs.c.CInt
    advanceX: libs.c.CInt
    image: Image
class Image
# Image, pixel data stored in CPU memory (RAM): 
    data: AnyPtr
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class Material
# Material, includes shader and maps
class MaterialMap
# MaterialMap: 
    texture: Texture2D
    color: Color
    value: float
class Matrix
# Matrix, 4x4 components, column major, OpenGL style, right-handed: 
    m0: float
    m4: float
    m8: float
    m12: float
    m1: float
    m5: float
    m9: float
    m13: float
    m2: float
    m6: float
    m10: float
    m14: float
    m3: float
    m7: float
    m11: float
    m15: float
class Mesh
# Mesh, vertex data and vao/vbo
class Model
# Model, meshes, materials and animation data
class ModelAnimation
# ModelAnimation
class Music
# Music, audio stream, anything longer than ~10 seconds should be streamed: 
    stream: AudioStream
    frameCount: libs.c.CUInt
    looping: bool
    ctxType: libs.c.CInt
    ctxData: AnyPtr
class NPatchInfo
# NPatchInfo, n-patch layout info: 
    source: Rectangle
    left: libs.c.CInt
    top: libs.c.CInt
    right: libs.c.CInt
    bottom: libs.c.CInt
    layout: libs.c.CInt
class Quaternion
# Quaternion, 4 components (Vector4 alias): 
    x: float
    y: float
    z: float
    w: float
class RAudioBufferPtr
class RAudioProcessorPtr
class Ray
# Ray, ray for raycasting: 
    position: Vector3
    direction: Vector3
class RayCollision
# RayCollision, ray hit information: 
    hit: bool
    distance: float
    point: Vector3
    normal: Vector3
class Rectangle
# Rectangle, 4 components: 
    x: float
    y: float
    width: float
    height: float
class RenderTexture
# RenderTexture, fbo for texture rendering: 
    id: libs.c.CUInt
    texture: Texture
    depth: Texture
class RenderTexture2D
# RenderTexture2D, same as RenderTexture: 
    id: libs.c.CUInt
    p_texture: Texture
    depth: Texture
class Shader
# Shader
class Sound
# Sound: 
    stream: AudioStream
    frameCount: libs.c.CUInt
class Texture
# Texture, tex data stored in GPU memory (VRAM): 
    id: libs.c.CUInt
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class Texture2D
# Texture2D, same as Texture: 
    id: libs.c.CUInt
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class TextureCubemap
# TextureCubemap, same as Texture: 
    id: libs.c.CUInt
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class Transform
# Transform, vertex transformation data: 
    translation: Vector3
    rotation: Quaternion
    scale: Vector3
class Vector2
# Vector2, 2 components: 
    x: float
    y: float
class Vector3
# Vector3, 3 components: 
    x: float
    y: float
    z: float
class Vector4
# Vector4, 4 components: 
    x: float
    y: float
    z: float
    w: float
class VrDeviceInfo
# VrDeviceInfo, Head-Mounted-Display device parameters
class VrStereoConfig
# VrStereoConfig, VR stereo rendering configuration for simulator
class Wave
# Wave, audio wave data: 
    frameCount: libs.c.CUInt
    sampleRate: libs.c.CUInt
    sampleSize: libs.c.CUInt
    channels: libs.c.CUInt
    data: AnyPtr
def begin_blend_mode(mode: int) -> None
# Begin blending mode (alpha, additive, multiplied, subtract, custom)
def begin_drawing() -> None
# Setup canvas (framebuffer) to start drawing
def begin_mode_2d(p_camera: Camera2D) -> None
# Begin 2D mode with custom camera (2D)
def begin_mode_3d(p_camera: Camera3D) -> None
# Begin 3D mode with custom camera (3D)
def begin_scissor_mode(x: int, y: int, width: int, height: int) -> None
# Begin scissor mode (define screen area for following drawing)
def begin_shader_mode(shader: Shader) -> None
# Begin custom shader drawing
def begin_texture_mode(target: RenderTexture2D) -> None
# Begin drawing to render texture
def begin_vr_stereo_mode(config: VrStereoConfig) -> None
# Begin stereo rendering (requires VR simulator)
def bounding_box(min: Vector3, max: Vector3) -> BoundingBox
# Factory function for: BoundingBox
def camera(position: Vector3, target: Vector3, up: Vector3, fovy: float, projection: int) -> Camera
# Factory function for: Camera
def camera_2d(offset: Vector2, target: Vector2, rotation: float, zoom: float) -> Camera2D
# Factory function for: Camera2D
def camera_3d(position: Vector3, target: Vector3, up: Vector3, fovy: float, projection: int) -> Camera3D
# Factory function for: Camera3D
def change_directory(dir: str) -> bool
# Change working directory, return true on success
def check_collision_box_sphere(box: BoundingBox, center: Vector3, radius: float) -> bool
# Check collision between box and sphere
def check_collision_boxes(box1: BoundingBox, box2: BoundingBox) -> bool
# Check collision between two bounding boxes
def check_collision_circle_rec(center: Vector2, radius: float, rec: Rectangle) -> bool
# Check collision between circle and rectangle
def check_collision_circles(center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool
# Check collision between two circles
def check_collision_lines(start_pos1: Vector2, end_pos1: Vector2, start_pos2: Vector2, end_pos2: Vector2, collision_point: Ptr[Vector2]) -> bool
# Check the collision between two lines defined by two points each, returns collision point by reference
def check_collision_point_circle(point: Vector2, center: Vector2, radius: float) -> bool
# Check if point is inside circle
def check_collision_point_line(point: Vector2, p1: Vector2, p2: Vector2, threshold: int) -> bool
# Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
def check_collision_point_poly(point: Vector2, points: Ptr[Vector2], point_count: int) -> bool
# Check if point is within a polygon described by array of vertices
def check_collision_point_rec(point: Vector2, rec: Rectangle) -> bool
# Check if point is inside rectangle
def check_collision_point_triangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool
# Check if point is inside a triangle
def check_collision_recs(rec1: Rectangle, rec2: Rectangle) -> bool
# Check collision between two rectangles
def check_collision_spheres(center1: Vector3, radius1: float, center2: Vector3, radius2: float) -> bool
# Check collision between two spheres
def clear_background(p_color: Color) -> None
# Set background color (framebuffer clear color)
def clear_window_state(flags: u32) -> None
# Clear window configuration state flags
def close_audio_device() -> None
# Close the audio device and context
def close_window() -> None
# Close window and unload OpenGL context
def codepoint_to_utf8(codepoint: int, utf8_size: Ptr[libs.c.CInt]) -> Ptr[Const[libs.c.CChar]]
# Encode one codepoint into UTF-8 byte array (array length returned as parameter)
def color(r: int, g: int, b: int, a: int) -> Color
# Factory function for: Color
def color_alpha(p_color: Color, alpha: float) -> Color
# Get color with alpha applied, alpha goes from 0.0f to 1.0f
def color_alpha_blend(dst: Color, src: Color, tint: Color) -> Color
# Get src alpha-blended into dst color with tint
def color_brightness(p_color: Color, factor: float) -> Color
# Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
def color_contrast(p_color: Color, contrast: float) -> Color
# Get color with contrast correction, contrast values between -1.0f and 1.0f
def color_from_hsv(hue: float, saturation: float, value: float) -> Color
# Get a Color from HSV values, hue [0..360], saturation/value [0..1]
def color_from_normalized(normalized: Vector4) -> Color
# Get Color from normalized values [0..1]
def color_normalize(p_color: Color) -> Vector4
# Get Color normalized as float [0..1]
def color_tint(p_color: Color, tint: Color) -> Color
# Get color multiplied with another color
def color_to_hsv(p_color: Color) -> Vector3
# Get HSV values for a Color, hue [0..360], saturation/value [0..1]
def color_to_int(p_color: Color) -> int
# Get hexadecimal value for a Color
def compress_data(data: Ptr[Const[libs.c.CUChar]], data_size: int, comp_data_size: Ptr[libs.c.CInt]) -> Ptr[libs.c.CUChar]
# Compress data (DEFLATE algorithm), memory must be MemFree()
def decode_data_base64(data: Ptr[Const[libs.c.CUChar]], output_size: Ptr[libs.c.CInt]) -> Ptr[libs.c.CUChar]
# Decode Base64 string data, memory must be MemFree()
def decompress_data(comp_data: Ptr[Const[libs.c.CUChar]], comp_data_size: int, data_size: Ptr[libs.c.CInt]) -> Ptr[libs.c.CUChar]
# Decompress data (DEFLATE algorithm), memory must be MemFree()
def directory_exists(dir_path: str) -> bool
# Check if a directory path exists
def disable_cursor() -> None
# Disables cursor (lock cursor)
def disable_event_waiting() -> None
# Disable waiting for events on EndDrawing(), automatic events polling
def draw_billboard(p_camera: Camera, p_texture: Texture2D, position: Vector3, size: float, tint: Color) -> None
# Draw a billboard texture
def draw_billboard_pro(p_camera: Camera, p_texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: float, tint: Color) -> None
# Draw a billboard texture defined by source and rotation
def draw_billboard_rec(p_camera: Camera, p_texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> None
# Draw a billboard texture defined by source
def draw_bounding_box(box: BoundingBox, p_color: Color) -> None
# Draw bounding box (wires)
def draw_capsule(start_pos: Vector3, end_pos: Vector3, radius: float, slices: int, rings: int, p_color: Color) -> None
# Draw a capsule with the center of its sphere caps at startPos and endPos
def draw_capsule_wires(start_pos: Vector3, end_pos: Vector3, radius: float, slices: int, rings: int, p_color: Color) -> None
# Draw capsule wireframe with the center of its sphere caps at startPos and endPos
def draw_circle(center_x: int, center_y: int, radius: float, p_color: Color) -> None
# Draw a color-filled circle
def draw_circle_3d(center: Vector3, radius: float, rotation_axis: Vector3, rotation_angle: float, p_color: Color) -> None
# Draw a circle in 3D world space
def draw_circle_gradient(center_x: int, center_y: int, radius: float, color1: Color, color2: Color) -> None
# Draw a gradient-filled circle
def draw_circle_lines(center_x: int, center_y: int, radius: float, p_color: Color) -> None
# Draw circle outline
def draw_circle_sector(center: Vector2, radius: float, start_angle: float, end_angle: float, segments: int, p_color: Color) -> None
# Draw a piece of a circle
def draw_circle_sector_lines(center: Vector2, radius: float, start_angle: float, end_angle: float, segments: int, p_color: Color) -> None
# Draw circle sector outline
def draw_circle_v(center: Vector2, radius: float, p_color: Color) -> None
# Draw a color-filled circle (Vector version)
def draw_cube(position: Vector3, width: float, height: float, length: float, p_color: Color) -> None
# Draw cube
def draw_cube_v(position: Vector3, size: Vector3, p_color: Color) -> None
# Draw cube (Vector version)
def draw_cube_wires(position: Vector3, width: float, height: float, length: float, p_color: Color) -> None
# Draw cube wires
def draw_cube_wires_v(position: Vector3, size: Vector3, p_color: Color) -> None
# Draw cube wires (Vector version)
def draw_cylinder(position: Vector3, radius_top: float, radius_bottom: float, height: float, slices: int, p_color: Color) -> None
# Draw a cylinder/cone
def draw_cylinder_ex(start_pos: Vector3, end_pos: Vector3, start_radius: float, end_radius: float, sides: int, p_color: Color) -> None
# Draw a cylinder with base at startPos and top at endPos
def draw_cylinder_wires(position: Vector3, radius_top: float, radius_bottom: float, height: float, slices: int, p_color: Color) -> None
# Draw a cylinder/cone wires
def draw_cylinder_wires_ex(start_pos: Vector3, end_pos: Vector3, start_radius: float, end_radius: float, sides: int, p_color: Color) -> None
# Draw a cylinder wires with base at startPos and top at endPos
def draw_ellipse(center_x: int, center_y: int, radius_h: float, radius_v: float, p_color: Color) -> None
# Draw ellipse
def draw_ellipse_lines(center_x: int, center_y: int, radius_h: float, radius_v: float, p_color: Color) -> None
# Draw ellipse outline
def draw_fps(pos_x: int, pos_y: int) -> None
# Draw current FPS
def draw_grid(slices: int, spacing: float) -> None
# Draw a grid (centered at (0, 0, 0))
def draw_line(start_pos_x: int, start_pos_y: int, end_pos_x: int, end_pos_y: int, p_color: Color) -> None
# Draw a line
def draw_line_3d(start_pos: Vector3, end_pos: Vector3, p_color: Color) -> None
# Draw a line in 3D world space
def draw_line_bezier(start_pos: Vector2, end_pos: Vector2, thick: float, p_color: Color) -> None
# Draw a line using cubic-bezier curves in-out
def draw_line_bezier_cubic(start_pos: Vector2, end_pos: Vector2, start_control_pos: Vector2, end_control_pos: Vector2, thick: float, p_color: Color) -> None
# Draw line using cubic bezier curves with 2 control points
def draw_line_bezier_quad(start_pos: Vector2, end_pos: Vector2, control_pos: Vector2, thick: float, p_color: Color) -> None
# Draw line using quadratic bezier curves with a control point
def draw_line_ex(start_pos: Vector2, end_pos: Vector2, thick: float, p_color: Color) -> None
# Draw a line defining thickness
def draw_line_strip(points: Ptr[Vector2], point_count: int, p_color: Color) -> None
# Draw lines sequence
def draw_line_v(start_pos: Vector2, end_pos: Vector2, p_color: Color) -> None
# Draw a line (Vector version)
def draw_mesh(mesh: Mesh, material: Material, p_transform: Matrix) -> None
# Draw a 3d mesh with material and transform
def draw_mesh_instanced(mesh: Mesh, material: Material, transforms: Ptr[Const[Matrix]], instances: int) -> None
# Draw multiple mesh instances with material and different transforms
def draw_model(model: Model, position: Vector3, scale: float, tint: Color) -> None
# Draw a model (with texture if set)
def draw_model_ex(model: Model, position: Vector3, rotation_axis: Vector3, rotation_angle: float, scale: Vector3, tint: Color) -> None
# Draw a model with extended parameters
def draw_model_wires(model: Model, position: Vector3, scale: float, tint: Color) -> None
# Draw a model wires (with texture if set)
def draw_model_wires_ex(model: Model, position: Vector3, rotation_axis: Vector3, rotation_angle: float, scale: Vector3, tint: Color) -> None
# Draw a model wires (with texture if set) with extended parameters
def draw_pixel(pos_x: int, pos_y: int, p_color: Color) -> None
# Draw a pixel
def draw_pixel_v(position: Vector2, p_color: Color) -> None
# Draw a pixel (Vector version)
def draw_plane(center_pos: Vector3, size: Vector2, p_color: Color) -> None
# Draw a plane XZ
def draw_point_3d(position: Vector3, p_color: Color) -> None
# Draw a point in 3D space, actually a small line
def draw_poly(center: Vector2, sides: int, radius: float, rotation: float, p_color: Color) -> None
# Draw a regular polygon (Vector version)
def draw_poly_lines(center: Vector2, sides: int, radius: float, rotation: float, p_color: Color) -> None
# Draw a polygon outline of n sides
def draw_poly_lines_ex(center: Vector2, sides: int, radius: float, rotation: float, line_thick: float, p_color: Color) -> None
# Draw a polygon outline of n sides with extended parameters
def draw_ray(p_ray: Ray, p_color: Color) -> None
# Draw a ray line
def draw_rectangle(pos_x: int, pos_y: int, width: int, height: int, p_color: Color) -> None
# Draw a color-filled rectangle
def draw_rectangle_gradient_ex(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color) -> None
# Draw a gradient-filled rectangle with custom vertex colors
def draw_rectangle_gradient_h(pos_x: int, pos_y: int, width: int, height: int, color1: Color, color2: Color) -> None
# Draw a horizontal-gradient-filled rectangle
def draw_rectangle_gradient_v(pos_x: int, pos_y: int, width: int, height: int, color1: Color, color2: Color) -> None
# Draw a vertical-gradient-filled rectangle
def draw_rectangle_lines(pos_x: int, pos_y: int, width: int, height: int, p_color: Color) -> None
# Draw rectangle outline
def draw_rectangle_lines_ex(rec: Rectangle, line_thick: float, p_color: Color) -> None
# Draw rectangle outline with extended parameters
def draw_rectangle_pro(rec: Rectangle, origin: Vector2, rotation: float, p_color: Color) -> None
# Draw a color-filled rectangle with pro parameters
def draw_rectangle_rec(rec: Rectangle, p_color: Color) -> None
# Draw a color-filled rectangle
def draw_rectangle_rounded(rec: Rectangle, roundness: float, segments: int, p_color: Color) -> None
# Draw rectangle with rounded edges
def draw_rectangle_rounded_lines(rec: Rectangle, roundness: float, segments: int, line_thick: float, p_color: Color) -> None
# Draw rectangle with rounded edges outline
def draw_rectangle_v(position: Vector2, size: Vector2, p_color: Color) -> None
# Draw a color-filled rectangle (Vector version)
def draw_ring(center: Vector2, inner_radius: float, outer_radius: float, start_angle: float, end_angle: float, segments: int, p_color: Color) -> None
# Draw ring
def draw_ring_lines(center: Vector2, inner_radius: float, outer_radius: float, start_angle: float, end_angle: float, segments: int, p_color: Color) -> None
# Draw ring outline
def draw_sphere(center_pos: Vector3, radius: float, p_color: Color) -> None
# Draw sphere
def draw_sphere_ex(center_pos: Vector3, radius: float, rings: int, slices: int, p_color: Color) -> None
# Draw sphere with extended parameters
def draw_sphere_wires(center_pos: Vector3, radius: float, rings: int, slices: int, p_color: Color) -> None
# Draw sphere wires
def draw_text(text: str, pos_x: int, pos_y: int, font_size: int, p_color: Color) -> None
# Draw text (using default font)
def draw_text_codepoint(p_font: Font, codepoint: int, position: Vector2, font_size: float, tint: Color) -> None
# Draw one character (codepoint)
def draw_text_codepoints(p_font: Font, codepoints: Ptr[Const[libs.c.CInt]], count: int, position: Vector2, font_size: float, spacing: float, tint: Color) -> None
# Draw multiple character (codepoint)
def draw_text_ex(p_font: Font, text: str, position: Vector2, font_size: float, spacing: float, tint: Color) -> None
# Draw text using font and additional parameters
def draw_text_pro(p_font: Font, text: str, position: Vector2, origin: Vector2, rotation: float, font_size: float, spacing: float, tint: Color) -> None
# Draw text using Font and pro parameters (rotation)
def draw_texture(p_texture: Texture2D, pos_x: int, pos_y: int, tint: Color) -> None
# Draw a Texture2D
def draw_texture_ex(p_texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color) -> None
# Draw a Texture2D with extended parameters
def draw_texture_n_patch(p_texture: Texture2D, p_n_patch_info: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: float, tint: Color) -> None
# Draws a texture (or part of it) that stretches or shrinks nicely
def draw_texture_pro(p_texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float, tint: Color) -> None
# Draw a part of a texture defined by a rectangle with 'pro' parameters
def draw_texture_rec(p_texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) -> None
# Draw a part of a texture defined by a rectangle
def draw_texture_v(p_texture: Texture2D, position: Vector2, tint: Color) -> None
# Draw a Texture2D with position defined as Vector2
def draw_triangle(v1: Vector2, v2: Vector2, v3: Vector2, p_color: Color) -> None
# Draw a color-filled triangle (vertex in counter-clockwise order!)
def draw_triangle_3d(v1: Vector3, v2: Vector3, v3: Vector3, p_color: Color) -> None
# Draw a color-filled triangle (vertex in counter-clockwise order!)
def draw_triangle_fan(points: Ptr[Vector2], point_count: int, p_color: Color) -> None
# Draw a triangle fan defined by points (first vertex is the center)
def draw_triangle_lines(v1: Vector2, v2: Vector2, v3: Vector2, p_color: Color) -> None
# Draw triangle outline (vertex in counter-clockwise order!)
def draw_triangle_strip(points: Ptr[Vector2], point_count: int, p_color: Color) -> None
# Draw a triangle strip defined by points
def draw_triangle_strip_3d(points: Ptr[Vector3], point_count: int, p_color: Color) -> None
# Draw a triangle strip defined by points
def enable_cursor() -> None
# Enables cursor (unlock cursor)
def enable_event_waiting() -> None
# Enable waiting for events on EndDrawing(), no automatic event polling
def encode_data_base64(data: Ptr[Const[libs.c.CUChar]], data_size: int, output_size: Ptr[libs.c.CInt]) -> libs.c.CStr
# Encode data to Base64 string, memory must be MemFree()
def end_blend_mode() -> None
# End blending mode (reset to default: alpha blending)
def end_drawing() -> None
# End canvas drawing and swap buffers (double buffering)
def end_mode_2d() -> None
# Ends 2D mode with custom camera
def end_mode_3d() -> None
# Ends 3D mode and returns to default 2D orthographic mode
def end_scissor_mode() -> None
# End scissor mode
def end_shader_mode() -> None
# End custom shader drawing (use default shader)
def end_texture_mode() -> None
# Ends drawing to render texture
def end_vr_stereo_mode() -> None
# End stereo rendering (requires VR simulator)
def export_data_as_code(data: Ptr[Const[libs.c.CUChar]], size: u32, file_name: str) -> bool
# Export data to code (.h), returns true on success
def export_font_as_code(p_font: Font, file_name: str) -> bool
# Export font as code file, returns true on success
def export_image(p_image: Image, file_name: str) -> bool
# Export image data to file, returns true on success
def export_image_as_code(p_image: Image, file_name: str) -> bool
# Export image as code file defining an array of bytes, returns true on success
def export_mesh(mesh: Mesh, file_name: str) -> bool
# Export mesh data to file, returns true on success
def export_wave(p_wave: Wave, file_name: str) -> bool
# Export wave data to file, returns true on success
def export_wave_as_code(p_wave: Wave, file_name: str) -> bool
# Export wave sample data to code (.h), returns true on success
def fade(p_color: Color, alpha: float) -> Color
# Get color with alpha applied, alpha goes from 0.0f to 1.0f
def file_exists(file_name: str) -> bool
# Check if file exists
def font(base_size: int, glyph_count: int, glyph_padding: int, p_texture: Texture2D, recs: Ptr[Rectangle], glyphs: Ptr[GlyphInfo]) -> Font
# Factory function for: Font
def gen_image_cellular(width: int, height: int, tile_size: int) -> Image
# Generate image: cellular algorithm, bigger tileSize means bigger cells
def gen_image_checked(width: int, height: int, checks_x: int, checks_y: int, col1: Color, col2: Color) -> Image
# Generate image: checked
def gen_image_color(width: int, height: int, p_color: Color) -> Image
# Generate image: plain color
def gen_image_font_atlas(chars: Ptr[Const[GlyphInfo]], recs: Ptr[Ptr[Rectangle]], glyph_count: int, font_size: int, padding: int, pack_method: int) -> Image
# Generate image font atlas using chars info
def gen_image_gradient_h(width: int, height: int, left: Color, right: Color) -> Image
# Generate image: horizontal gradient
def gen_image_gradient_radial(width: int, height: int, density: float, inner: Color, outer: Color) -> Image
# Generate image: radial gradient
def gen_image_gradient_v(width: int, height: int, top: Color, bottom: Color) -> Image
# Generate image: vertical gradient
def gen_image_perlin_noise(width: int, height: int, offset_x: int, offset_y: int, scale: float) -> Image
# Generate image: perlin noise
def gen_image_text(width: int, height: int, text: str) -> Image
# Generate image: grayscale image from text data
def gen_image_white_noise(width: int, height: int, factor: float) -> Image
# Generate image: white noise
def gen_mesh_cone(radius: float, height: float, slices: int) -> Mesh
# Generate cone/pyramid mesh
def gen_mesh_cube(width: float, height: float, length: float) -> Mesh
# Generate cuboid mesh
def gen_mesh_cubicmap(cubicmap: Image, cube_size: Vector3) -> Mesh
# Generate cubes-based map mesh from image data
def gen_mesh_cylinder(radius: float, height: float, slices: int) -> Mesh
# Generate cylinder mesh
def gen_mesh_heightmap(heightmap: Image, size: Vector3) -> Mesh
# Generate heightmap mesh from image data
def gen_mesh_hemi_sphere(radius: float, rings: int, slices: int) -> Mesh
# Generate half-sphere mesh (no bottom cap)
def gen_mesh_knot(radius: float, size: float, rad_seg: int, sides: int) -> Mesh
# Generate trefoil knot mesh
def gen_mesh_plane(width: float, length: float, res_x: int, res_z: int) -> Mesh
# Generate plane mesh (with subdivisions)
def gen_mesh_poly(sides: int, radius: float) -> Mesh
# Generate polygonal mesh
def gen_mesh_sphere(radius: float, rings: int, slices: int) -> Mesh
# Generate sphere mesh (standard sphere)
def gen_mesh_tangents(mesh: Ptr[Mesh]) -> None
# Compute mesh tangents
def gen_mesh_torus(radius: float, size: float, rad_seg: int, sides: int) -> Mesh
# Generate torus mesh
def gen_texture_mipmaps(p_texture: Ptr[Texture2D]) -> None
# Generate GPU mipmaps for a texture
def get_application_directory() -> Ptr[Const[libs.c.CChar]]
# Get the directory if the running application (uses static string)
def get_camera_matrix(p_camera: Camera) -> Matrix
# Get camera transform matrix (view matrix)
def get_camera_matrix_2d(p_camera: Camera2D) -> Matrix
# Get camera 2d transform matrix
def get_char_pressed() -> int
# Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
def get_clipboard_text() -> Ptr[Const[libs.c.CChar]]
# Get clipboard text content
def get_codepoint(text: str, codepoint_size: Ptr[libs.c.CInt]) -> int
# Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
def get_codepoint_count(text: str) -> int
# Get total number of codepoints in a UTF-8 encoded string
def get_codepoint_next(text: str, codepoint_size: Ptr[libs.c.CInt]) -> int
# Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
def get_codepoint_previous(text: str, codepoint_size: Ptr[libs.c.CInt]) -> int
# Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
def get_collision_rec(rec1: Rectangle, rec2: Rectangle) -> Rectangle
# Get collision rectangle for two rectangles collision
def get_color(hex_value: u32) -> Color
# Get Color structure from hexadecimal value
def get_current_monitor() -> int
# Get current connected monitor
def get_directory_path(file_path: str) -> Ptr[Const[libs.c.CChar]]
# Get full path for a given fileName with path (uses static string)
def get_file_extension(file_name: str) -> Ptr[Const[libs.c.CChar]]
# Get pointer to extension for a filename string (includes dot: '.png')
def get_file_length(file_name: str) -> int
# Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
def get_file_mod_time(file_name: str) -> i64
# Get file modification time (last write time)
def get_file_name(file_path: str) -> Ptr[Const[libs.c.CChar]]
# Get pointer to filename for a path string
def get_file_name_without_ext(file_path: str) -> Ptr[Const[libs.c.CChar]]
# Get filename string without extension (uses static string)
def get_font_default() -> Font
# Get the default Font
def get_fps() -> int
# Get current FPS
def get_frame_time() -> float
# Get time in seconds for last frame drawn (delta time)
def get_gamepad_axis_count(gamepad: int) -> int
# Get gamepad axis count for a gamepad
def get_gamepad_axis_movement(gamepad: int, axis: int) -> float
# Get axis movement value for a gamepad axis
def get_gamepad_button_pressed() -> int
# Get the last gamepad button pressed
def get_gamepad_name(gamepad: int) -> Ptr[Const[libs.c.CChar]]
# Get gamepad internal name id
def get_gesture_detected() -> int
# Get latest detected gesture
def get_gesture_drag_angle() -> float
# Get gesture drag angle
def get_gesture_drag_vector() -> Vector2
# Get gesture drag vector
def get_gesture_hold_duration() -> float
# Get gesture hold time in milliseconds
def get_gesture_pinch_angle() -> float
# Get gesture pinch angle
def get_gesture_pinch_vector() -> Vector2
# Get gesture pinch delta
def get_glyph_atlas_rec(p_font: Font, codepoint: int) -> Rectangle
# Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
def get_glyph_index(p_font: Font, codepoint: int) -> int
# Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
def get_glyph_info(p_font: Font, codepoint: int) -> GlyphInfo
# Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
def get_image_alpha_border(p_image: Image, threshold: float) -> Rectangle
# Get image alpha border rectangle
def get_image_color(p_image: Image, x: int, y: int) -> Color
# Get image pixel color at (x, y) position
def get_key_pressed() -> int
# Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
def get_mesh_bounding_box(mesh: Mesh) -> BoundingBox
# Compute mesh bounding box limits
def get_model_bounding_box(model: Model) -> BoundingBox
# Compute model bounding box limits (considers all meshes)
def get_monitor_count() -> int
# Get number of connected monitors
def get_monitor_height(monitor: int) -> int
# Get specified monitor height (current video mode used by monitor)
def get_monitor_name(monitor: int) -> Ptr[Const[libs.c.CChar]]
# Get the human-readable, UTF-8 encoded name of the primary monitor
def get_monitor_physical_height(monitor: int) -> int
# Get specified monitor physical height in millimetres
def get_monitor_physical_width(monitor: int) -> int
# Get specified monitor physical width in millimetres
def get_monitor_position(monitor: int) -> Vector2
# Get specified monitor position
def get_monitor_refresh_rate(monitor: int) -> int
# Get specified monitor refresh rate
def get_monitor_width(monitor: int) -> int
# Get specified monitor width (current video mode used by monitor)
def get_mouse_delta() -> Vector2
# Get mouse delta between frames
def get_mouse_position() -> Vector2
# Get mouse position XY
def get_mouse_ray(mouse_position: Vector2, p_camera: Camera) -> Ray
# Get a ray trace from mouse position
def get_mouse_wheel_move() -> float
# Get mouse wheel movement for X or Y, whichever is larger
def get_mouse_wheel_move_v() -> Vector2
# Get mouse wheel movement for both X and Y
def get_mouse_x() -> int
# Get mouse position X
def get_mouse_y() -> int
# Get mouse position Y
def get_music_time_length(p_music: Music) -> float
# Get music time length (in seconds)
def get_music_time_played(p_music: Music) -> float
# Get current music time played (in seconds)
def get_pixel_color(src_ptr: AnyPtr, format: int) -> Color
# Get Color from a source pixel pointer of certain format
def get_pixel_data_size(width: int, height: int, format: int) -> int
# Get pixel data size in bytes for certain format
def get_prev_directory_path(dir_path: str) -> Ptr[Const[libs.c.CChar]]
# Get previous directory path for a given path (uses static string)
def get_random_value(min: int, max: int) -> int
# Get a random value between min and max (both included)
def get_ray_collision_box(p_ray: Ray, box: BoundingBox) -> RayCollision
# Get collision info between ray and box
def get_ray_collision_mesh(p_ray: Ray, mesh: Mesh, p_transform: Matrix) -> RayCollision
# Get collision info between ray and mesh
def get_ray_collision_quad(p_ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision
# Get collision info between ray and quad
def get_ray_collision_sphere(p_ray: Ray, center: Vector3, radius: float) -> RayCollision
# Get collision info between ray and sphere
def get_ray_collision_triangle(p_ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision
# Get collision info between ray and triangle
def get_render_height() -> int
# Get current render height (it considers HiDPI)
def get_render_width() -> int
# Get current render width (it considers HiDPI)
def get_screen_height() -> int
# Get current screen height
def get_screen_to_world_2d(position: Vector2, p_camera: Camera2D) -> Vector2
# Get the world space position for a 2d camera screen space position
def get_screen_width() -> int
# Get current screen width
def get_shader_location(shader: Shader, uniform_name: str) -> int
# Get shader uniform location
def get_shader_location_attrib(shader: Shader, attrib_name: str) -> int
# Get shader attribute location
def get_time() -> f64
# Get elapsed time in seconds since InitWindow()
def get_touch_point_count() -> int
# Get number of touch points
def get_touch_point_id(index: int) -> int
# Get touch point identifier for given index
def get_touch_position(index: int) -> Vector2
# Get touch position XY for a touch point index (relative to screen size)
def get_touch_x() -> int
# Get touch position X for touch point 0 (relative to screen size)
def get_touch_y() -> int
# Get touch position Y for touch point 0 (relative to screen size)
def get_window_handle() -> AnyPtr
# Get native window handle
def get_window_position() -> Vector2
# Get window position XY on monitor
def get_window_scale_dpi() -> Vector2
# Get window scale DPI factor
def get_working_directory() -> Ptr[Const[libs.c.CChar]]
# Get current working directory (uses static string)
def get_world_to_screen(position: Vector3, p_camera: Camera) -> Vector2
# Get the screen space position for a 3d world space position
def get_world_to_screen_2d(position: Vector2, p_camera: Camera2D) -> Vector2
# Get the screen space position for a 2d camera world space position
def get_world_to_screen_ex(position: Vector3, p_camera: Camera, width: int, height: int) -> Vector2
# Get size position for a 3d world space position
def glyph_info(value: int, offset_x: int, offset_y: int, advance_x: int, p_image: Image) -> GlyphInfo
# Factory function for: GlyphInfo
def hide_cursor() -> None
# Hides cursor
def image(data: AnyPtr, width: int, height: int, mipmaps: int, format: int) -> Image
# Factory function for: Image
def image_alpha_clear(p_image: Ptr[Image], p_color: Color, threshold: float) -> None
# Clear alpha channel to desired color
def image_alpha_crop(p_image: Ptr[Image], threshold: float) -> None
# Crop image depending on alpha value
def image_alpha_mask(p_image: Ptr[Image], alpha_mask: Image) -> None
# Apply alpha mask to image
def image_alpha_premultiply(p_image: Ptr[Image]) -> None
# Premultiply alpha channel
def image_blur_gaussian(p_image: Ptr[Image], blur_size: int) -> None
# Apply Gaussian blur using a box blur approximation
def image_clear_background(dst: Ptr[Image], p_color: Color) -> None
# Clear image background with given color
def image_color_brightness(p_image: Ptr[Image], brightness: int) -> None
# Modify image color: brightness (-255 to 255)
def image_color_contrast(p_image: Ptr[Image], contrast: float) -> None
# Modify image color: contrast (-100 to 100)
def image_color_grayscale(p_image: Ptr[Image]) -> None
# Modify image color: grayscale
def image_color_invert(p_image: Ptr[Image]) -> None
# Modify image color: invert
def image_color_replace(p_image: Ptr[Image], p_color: Color, replace: Color) -> None
# Modify image color: replace color
def image_color_tint(p_image: Ptr[Image], p_color: Color) -> None
# Modify image color: tint
def image_copy(p_image: Image) -> Image
# Create an image duplicate (useful for transformations)
def image_crop(p_image: Ptr[Image], crop: Rectangle) -> None
# Crop an image to a defined rectangle
def image_dither(p_image: Ptr[Image], r_bpp: int, g_bpp: int, b_bpp: int, a_bpp: int) -> None
# Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
def image_draw(dst: Ptr[Image], src: Image, src_rec: Rectangle, dst_rec: Rectangle, tint: Color) -> None
# Draw a source image within a destination image (tint applied to source)
def image_draw_circle(dst: Ptr[Image], center_x: int, center_y: int, radius: int, p_color: Color) -> None
# Draw a filled circle within an image
def image_draw_circle_lines(dst: Ptr[Image], center_x: int, center_y: int, radius: int, p_color: Color) -> None
# Draw circle outline within an image
def image_draw_circle_lines_v(dst: Ptr[Image], center: Vector2, radius: int, p_color: Color) -> None
# Draw circle outline within an image (Vector version)
def image_draw_circle_v(dst: Ptr[Image], center: Vector2, radius: int, p_color: Color) -> None
# Draw a filled circle within an image (Vector version)
def image_draw_line(dst: Ptr[Image], start_pos_x: int, start_pos_y: int, end_pos_x: int, end_pos_y: int, p_color: Color) -> None
# Draw line within an image
def image_draw_line_v(dst: Ptr[Image], start: Vector2, end: Vector2, p_color: Color) -> None
# Draw line within an image (Vector version)
def image_draw_pixel(dst: Ptr[Image], pos_x: int, pos_y: int, p_color: Color) -> None
# Draw pixel within an image
def image_draw_pixel_v(dst: Ptr[Image], position: Vector2, p_color: Color) -> None
# Draw pixel within an image (Vector version)
def image_draw_rectangle(dst: Ptr[Image], pos_x: int, pos_y: int, width: int, height: int, p_color: Color) -> None
# Draw rectangle within an image
def image_draw_rectangle_lines(dst: Ptr[Image], rec: Rectangle, thick: int, p_color: Color) -> None
# Draw rectangle lines within an image
def image_draw_rectangle_rec(dst: Ptr[Image], rec: Rectangle, p_color: Color) -> None
# Draw rectangle within an image
def image_draw_rectangle_v(dst: Ptr[Image], position: Vector2, size: Vector2, p_color: Color) -> None
# Draw rectangle within an image (Vector version)
def image_draw_text(dst: Ptr[Image], text: str, pos_x: int, pos_y: int, font_size: int, p_color: Color) -> None
# Draw text (using default font) within an image (destination)
def image_draw_text_ex(dst: Ptr[Image], p_font: Font, text: str, position: Vector2, font_size: float, spacing: float, tint: Color) -> None
# Draw text (custom sprite font) within an image (destination)
def image_flip_horizontal(p_image: Ptr[Image]) -> None
# Flip image horizontally
def image_flip_vertical(p_image: Ptr[Image]) -> None
# Flip image vertically
def image_format(p_image: Ptr[Image], new_format: int) -> None
# Convert image data to desired format
def image_from_image(p_image: Image, rec: Rectangle) -> Image
# Create an image from another image piece
def image_mipmaps(p_image: Ptr[Image]) -> None
# Compute all mipmap levels for a provided image
def image_resize(p_image: Ptr[Image], new_width: int, new_height: int) -> None
# Resize image (Bicubic scaling algorithm)
def image_resize_canvas(p_image: Ptr[Image], new_width: int, new_height: int, offset_x: int, offset_y: int, fill: Color) -> None
# Resize canvas and fill with color
def image_resize_nn(p_image: Ptr[Image], new_width: int, new_height: int) -> None
# Resize image (Nearest-Neighbor scaling algorithm)
def image_rotate_ccw(p_image: Ptr[Image]) -> None
# Rotate image counter-clockwise 90deg
def image_rotate_cw(p_image: Ptr[Image]) -> None
# Rotate image clockwise 90deg
def image_text(text: str, font_size: int, p_color: Color) -> Image
# Create an image from text (default font)
def image_text_ex(p_font: Font, text: str, font_size: float, spacing: float, tint: Color) -> Image
# Create an image from text (custom sprite font)
def image_to_pot(p_image: Ptr[Image], fill: Color) -> None
# Convert image to POT (power-of-two)
def init_audio_device() -> None
# Initialize audio device and context
def init_window(width: int, height: int, title: str) -> None
# Initialize window and OpenGL context
def is_audio_device_ready() -> bool
# Check if audio device has been initialized successfully
def is_audio_stream_playing(stream: AudioStream) -> bool
# Check if audio stream is playing
def is_audio_stream_processed(stream: AudioStream) -> bool
# Check if any audio stream buffers requires refill
def is_audio_stream_ready(stream: AudioStream) -> bool
# Checks if an audio stream is ready
def is_cursor_hidden() -> bool
# Check if cursor is not visible
def is_cursor_on_screen() -> bool
# Check if cursor is on the screen
def is_file_dropped() -> bool
# Check if a file has been dropped into window
def is_file_extension(file_name: str, ext: str) -> bool
# Check file extension (including point: .png, .wav)
def is_font_ready(p_font: Font) -> bool
# Check if a font is ready
def is_gamepad_available(gamepad: int) -> bool
# Check if a gamepad is available
def is_gamepad_button_down(gamepad: int, button: int) -> bool
# Check if a gamepad button is being pressed
def is_gamepad_button_pressed(gamepad: int, button: int) -> bool
# Check if a gamepad button has been pressed once
def is_gamepad_button_released(gamepad: int, button: int) -> bool
# Check if a gamepad button has been released once
def is_gamepad_button_up(gamepad: int, button: int) -> bool
# Check if a gamepad button is NOT being pressed
def is_gesture_detected(gesture: int) -> bool
# Check if a gesture have been detected
def is_image_ready(p_image: Image) -> bool
# Check if an image is ready
def is_key_down(key: int) -> bool
# Check if a key is being pressed
def is_key_pressed(key: int) -> bool
# Check if a key has been pressed once
def is_key_released(key: int) -> bool
# Check if a key has been released once
def is_key_up(key: int) -> bool
# Check if a key is NOT being pressed
def is_material_ready(material: Material) -> bool
# Check if a material is ready
def is_model_animation_valid(model: Model, anim: ModelAnimation) -> bool
# Check model animation skeleton match
def is_model_ready(model: Model) -> bool
# Check if a model is ready
def is_mouse_button_down(button: int) -> bool
# Check if a mouse button is being pressed
def is_mouse_button_pressed(button: int) -> bool
# Check if a mouse button has been pressed once
def is_mouse_button_released(button: int) -> bool
# Check if a mouse button has been released once
def is_mouse_button_up(button: int) -> bool
# Check if a mouse button is NOT being pressed
def is_music_ready(p_music: Music) -> bool
# Checks if a music stream is ready
def is_music_stream_playing(p_music: Music) -> bool
# Check if music is playing
def is_path_file(path: str) -> bool
# Check if a given path is a file or a directory
def is_render_texture_ready(target: RenderTexture2D) -> bool
# Check if a render texture is ready
def is_shader_ready(shader: Shader) -> bool
# Check if a shader is ready
def is_sound_playing(p_sound: Sound) -> bool
# Check if a sound is currently playing
def is_sound_ready(p_sound: Sound) -> bool
# Checks if a sound is ready
def is_texture_ready(p_texture: Texture2D) -> bool
# Check if a texture is ready
def is_wave_ready(p_wave: Wave) -> bool
# Checks if wave data is ready
def is_window_focused() -> bool
# Check if window is currently focused (only PLATFORM_DESKTOP)
def is_window_fullscreen() -> bool
# Check if window is currently fullscreen
def is_window_hidden() -> bool
# Check if window is currently hidden (only PLATFORM_DESKTOP)
def is_window_maximized() -> bool
# Check if window is currently maximized (only PLATFORM_DESKTOP)
def is_window_minimized() -> bool
# Check if window is currently minimized (only PLATFORM_DESKTOP)
def is_window_ready() -> bool
# Check if window has been initialized successfully
def is_window_resized() -> bool
# Check if window has been resized last frame
def is_window_state(flag: u32) -> bool
# Check if one specific window flag is enabled
def load_audio_stream(sample_rate: u32, sample_size: u32, channels: u32) -> AudioStream
# Load audio stream (to stream raw audio pcm data)
def load_codepoints(text: str, count: Ptr[libs.c.CInt]) -> Ptr[libs.c.CInt]
# Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
def load_directory_files(dir_path: str) -> FilePathList
# Load directory filepaths
def load_directory_files_ex(base_path: str, filter: str, scan_subdirs: bool) -> FilePathList
# Load directory filepaths with extension filtering and recursive directory scan
def load_dropped_files() -> FilePathList
# Load dropped filepaths
def load_file_data(file_name: str, bytes_read: Ptr[libs.c.CUInt]) -> Ptr[libs.c.CUChar]
# Load file data as byte array (read)
def load_file_text(file_name: str) -> libs.c.CStr
# Load text data from file (read), returns a '\0' terminated string
def load_font(file_name: str) -> Font
# Load font from file into GPU memory (VRAM)
def load_font_data(file_data: Ptr[Const[libs.c.CUChar]], data_size: int, font_size: int, font_chars: Ptr[libs.c.CInt], glyph_count: int, type: int) -> Ptr[GlyphInfo]
# Load font data for further use
def load_font_ex(file_name: str, font_size: int, font_chars: Ptr[libs.c.CInt], glyph_count: int) -> Font
# Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set
def load_font_from_image(p_image: Image, key: Color, first_char: int) -> Font
# Load font from Image (XNA style)
def load_font_from_memory(file_type: str, file_data: Ptr[Const[libs.c.CUChar]], data_size: int, font_size: int, font_chars: Ptr[libs.c.CInt], glyph_count: int) -> Font
# Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
def load_image(file_name: str) -> Image
# Load image from file into CPU memory (RAM)
def load_image_anim(file_name: str, frames: Ptr[libs.c.CInt]) -> Image
# Load image sequence from file (frames appended to image.data)
def load_image_colors(p_image: Image) -> Ptr[Color]
# Load color data from image as a Color array (RGBA - 32bit)
def load_image_from_memory(file_type: str, file_data: Ptr[Const[libs.c.CUChar]], data_size: int) -> Image
# Load image from memory buffer, fileType refers to extension: i.e. '.png'
def load_image_from_screen() -> Image
# Load image from screen buffer and (screenshot)
def load_image_from_texture(p_texture: Texture2D) -> Image
# Load image from GPU texture data
def load_image_palette(p_image: Image, max_palette_size: int, color_count: Ptr[libs.c.CInt]) -> Ptr[Color]
# Load colors palette from image as a Color array (RGBA - 32bit)
def load_image_raw(file_name: str, width: int, height: int, format: int, header_size: int) -> Image
# Load image from RAW file data
def load_material_default() -> Material
# Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
def load_materials(file_name: str, material_count: Ptr[libs.c.CInt]) -> Ptr[Material]
# Load materials from model file
def load_model(file_name: str) -> Model
# Load model from files (meshes and materials)
def load_model_animations(file_name: str, anim_count: Ptr[libs.c.CUInt]) -> Ptr[ModelAnimation]
# Load model animations from file
def load_model_from_mesh(mesh: Mesh) -> Model
# Load model from generated mesh (default material)
def load_music_stream(file_name: str) -> Music
# Load music stream from file
def load_music_stream_from_memory(file_type: str, data: Ptr[Const[libs.c.CUChar]], data_size: int) -> Music
# Load music stream from data
def load_render_texture(width: int, height: int) -> RenderTexture2D
# Load texture for rendering (framebuffer)
def load_shader(vs_file_name: str, fs_file_name: str) -> Shader
# Load shader from files and bind default locations
def load_shader_from_memory(vs_code: str, fs_code: str) -> Shader
# Load shader from code strings and bind default locations
def load_sound(file_name: str) -> Sound
# Load sound from file
def load_sound_from_wave(p_wave: Wave) -> Sound
# Load sound from wave data
def load_texture(file_name: str) -> Texture2D
# Load texture from file into GPU memory (VRAM)
def load_texture_cubemap(p_image: Image, layout: int) -> TextureCubemap
# Load cubemap from image, multiple image cubemap layouts supported
def load_texture_from_image(p_image: Image) -> Texture2D
# Load texture from image data
def load_utf8(codepoints: Ptr[Const[libs.c.CInt]], length: int) -> libs.c.CStr
# Load UTF-8 text encoded from codepoints array
def load_vr_stereo_config(device: VrDeviceInfo) -> VrStereoConfig
# Load VR stereo config for VR simulator device parameters
def load_wave(file_name: str) -> Wave
# Load wave data from file
def load_wave_from_memory(file_type: str, file_data: Ptr[Const[libs.c.CUChar]], data_size: int) -> Wave
# Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
def load_wave_samples(p_wave: Wave) -> Ptr[libs.c.CFloat]
# Load samples data from wave as a 32bit float data array
def material_map(p_texture: Texture2D, p_color: Color, value: float) -> MaterialMap
# Factory function for: MaterialMap
def matrix(m0: float, m4: float, m8: float, m12: float, m1: float, m5: float, m9: float, m13: float, m2: float, m6: float, m10: float, m14: float, m3: float, m7: float, m11: float, m15: float) -> Matrix
# Factory function for: Matrix
def maximize_window() -> None
# Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
def measure_text(text: str, font_size: int) -> int
# Measure string width for default font
def measure_text_ex(p_font: Font, text: str, font_size: float, spacing: float) -> Vector2
# Measure string size for Font
def mem_alloc(size: u32) -> AnyPtr
# Internal memory allocator
def mem_free(ptr: AnyPtr) -> None
# Internal memory free
def mem_realloc(ptr: AnyPtr, size: u32) -> AnyPtr
# Internal memory reallocator
def minimize_window() -> None
# Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
def music(stream: AudioStream, frame_count: u32, looping: bool, ctx_type: int, ctx_data: AnyPtr) -> Music
# Factory function for: Music
def n_patch_info(source: Rectangle, left: int, top: int, right: int, bottom: int, layout: int) -> NPatchInfo
# Factory function for: NPatchInfo
def open_url(url: str) -> None
# Open URL with default system browser (if available)
def pause_audio_stream(stream: AudioStream) -> None
# Pause audio stream
def pause_music_stream(p_music: Music) -> None
# Pause music playing
def pause_sound(p_sound: Sound) -> None
# Pause a sound
def play_audio_stream(stream: AudioStream) -> None
# Play audio stream
def play_music_stream(p_music: Music) -> None
# Start music playing
def play_sound(p_sound: Sound) -> None
# Play a sound
def poll_input_events() -> None
# Register all input events
def quaternion(x: float, y: float, z: float, w: float) -> Quaternion
# Factory function for: Quaternion
def ray(position: Vector3, direction: Vector3) -> Ray
# Factory function for: Ray
def ray_collision(hit: bool, distance: float, point: Vector3, normal: Vector3) -> RayCollision
# Factory function for: RayCollision
def rectangle(x: float, y: float, width: float, height: float) -> Rectangle
# Factory function for: Rectangle
def render_texture(id: u32, p_texture: Texture, depth: Texture) -> RenderTexture
# Factory function for: RenderTexture
def render_texture_2d(id: u32, p_texture: Texture, depth: Texture) -> RenderTexture2D
# Factory function for: RenderTexture2D
def restore_window() -> None
# Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
def resume_audio_stream(stream: AudioStream) -> None
# Resume audio stream
def resume_music_stream(p_music: Music) -> None
# Resume playing paused music
def resume_sound(p_sound: Sound) -> None
# Resume a paused sound
def save_file_data(file_name: str, data: AnyPtr, bytes_to_write: u32) -> bool
# Save data to file from byte array (write), returns true on success
def save_file_text(file_name: str, text: str) -> bool
# Save text data to file (write), string must be '\0' terminated, returns true on success
def seek_music_stream(p_music: Music, position: float) -> None
# Seek music to a position (in seconds)
def set_audio_stream_buffer_size_default(size: int) -> None
# Default size for new audio streams
def set_audio_stream_pan(stream: AudioStream, pan: float) -> None
# Set pan for audio stream (0.5 is centered)
def set_audio_stream_pitch(stream: AudioStream, pitch: float) -> None
# Set pitch for audio stream (1.0 is base level)
def set_audio_stream_volume(stream: AudioStream, volume: float) -> None
# Set volume for audio stream (1.0 is max level)
def set_clipboard_text(text: str) -> None
# Set clipboard text content
def set_config_flags(flags: u32) -> None
# Setup init configuration flags (view FLAGS)
def set_exit_key(key: int) -> None
# Set a custom key to exit program (default is ESC)
def set_gamepad_mappings(mappings: str) -> int
# Set internal gamepad mappings (SDL_GameControllerDB)
def set_gestures_enabled(flags: u32) -> None
# Enable a set of gestures using flags
def set_master_volume(volume: float) -> None
# Set master volume (listener)
def set_material_texture(material: Ptr[Material], map_type: int, p_texture: Texture2D) -> None
# Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
def set_model_mesh_material(model: Ptr[Model], mesh_id: int, material_id: int) -> None
# Set material for a mesh
def set_mouse_cursor(cursor: int) -> None
# Set mouse cursor
def set_mouse_offset(offset_x: int, offset_y: int) -> None
# Set mouse offset
def set_mouse_position(x: int, y: int) -> None
# Set mouse position XY
def set_mouse_scale(scale_x: float, scale_y: float) -> None
# Set mouse scaling
def set_music_pan(p_music: Music, pan: float) -> None
# Set pan for a music (0.5 is center)
def set_music_pitch(p_music: Music, pitch: float) -> None
# Set pitch for a music (1.0 is base level)
def set_music_volume(p_music: Music, volume: float) -> None
# Set volume for music (1.0 is max level)
def set_pixel_color(dst_ptr: AnyPtr, p_color: Color, format: int) -> None
# Set color formatted into destination pixel pointer
def set_random_seed(seed: u32) -> None
# Set the seed for the random number generator
def set_shader_value(shader: Shader, loc_index: int, value: AnyPtrToConst, uniform_type: int) -> None
# Set shader uniform value
def set_shader_value_matrix(shader: Shader, loc_index: int, mat: Matrix) -> None
# Set shader uniform value (matrix 4x4)
def set_shader_value_texture(shader: Shader, loc_index: int, p_texture: Texture2D) -> None
# Set shader uniform value for texture (sampler2d)
def set_shader_value_v(shader: Shader, loc_index: int, value: AnyPtrToConst, uniform_type: int, count: int) -> None
# Set shader uniform value vector
def set_shapes_texture(p_texture: Texture2D, source: Rectangle) -> None
# Set texture and rectangle to be used on shapes drawing
def set_sound_pan(p_sound: Sound, pan: float) -> None
# Set pan for a sound (0.5 is center)
def set_sound_pitch(p_sound: Sound, pitch: float) -> None
# Set pitch for a sound (1.0 is base level)
def set_sound_volume(p_sound: Sound, volume: float) -> None
# Set volume for a sound (1.0 is max level)
def set_target_fps(fps: int) -> None
# Set target FPS (maximum)
def set_texture_filter(p_texture: Texture2D, filter: int) -> None
# Set texture scaling filter mode
def set_texture_wrap(p_texture: Texture2D, wrap: int) -> None
# Set texture wrapping mode
def set_trace_log_level(log_level: int) -> None
# Set the current threshold (minimum) log level
def set_window_icon(p_image: Image) -> None
# Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)
def set_window_icons(images: Ptr[Image], count: int) -> None
# Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)
def set_window_min_size(width: int, height: int) -> None
# Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
def set_window_monitor(monitor: int) -> None
# Set monitor for the current window (fullscreen mode)
def set_window_opacity(opacity: float) -> None
# Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
def set_window_position(x: int, y: int) -> None
# Set window position on screen (only PLATFORM_DESKTOP)
def set_window_size(width: int, height: int) -> None
# Set window dimensions
def set_window_state(flags: u32) -> None
# Set window configuration state using flags (only PLATFORM_DESKTOP)
def set_window_title(title: str) -> None
# Set title for window (only PLATFORM_DESKTOP)
def show_cursor() -> None
# Shows cursor
def sound(stream: AudioStream, frame_count: u32) -> Sound
# Factory function for: Sound
def stop_audio_stream(stream: AudioStream) -> None
# Stop audio stream
def stop_music_stream(p_music: Music) -> None
# Stop music playing
def stop_sound(p_sound: Sound) -> None
# Stop playing a sound
def swap_screen_buffer() -> None
# Swap back buffer with front buffer (screen drawing)
def take_screenshot(file_name: str) -> None
# Takes a screenshot of current screen (filename extension defines format)
def text_append(text: str, append: str, position: Ptr[libs.c.CInt]) -> None
# Append text at specific position and move cursor!
def text_copy(dst: str, src: str) -> int
# Copy one string to another, returns bytes copied
def text_find_index(text: str, find: str) -> int
# Find first text occurrence within a string
def text_insert(text: str, insert: str, position: int) -> libs.c.CStr
# Insert text in a position (WARNING: memory must be freed!)
def text_is_equal(text1: str, text2: str) -> bool
# Check if two text string are equal
def text_join(text_list: Ptr[Ptr[Const[libs.c.CChar]]], count: int, delimiter: str) -> Ptr[Const[libs.c.CChar]]
# Join text strings with delimiter
def text_length(text: str) -> u32
# Get text length, checks for '\0' ending
def text_replace(text: str, replace: str, by: str) -> libs.c.CStr
# Replace text string (WARNING: memory must be freed!)
def text_split(text: str, delimiter: int, count: Ptr[libs.c.CInt]) -> Ptr[Ptr[Const[libs.c.CChar]]]
# Split text into multiple strings
def text_subtext(text: str, position: int, length: int) -> Ptr[Const[libs.c.CChar]]
# Get a piece of a text string
def text_to_integer(text: str) -> int
# Get integer value from text (negative values not supported)
def text_to_lower(text: str) -> Ptr[Const[libs.c.CChar]]
# Get lower case version of provided string
def text_to_pascal(text: str) -> Ptr[Const[libs.c.CChar]]
# Get Pascal case notation version of provided string
def text_to_upper(text: str) -> Ptr[Const[libs.c.CChar]]
# Get upper case version of provided string
def texture(id: u32, width: int, height: int, mipmaps: int, format: int) -> Texture
# Factory function for: Texture
def texture_2d(id: u32, width: int, height: int, mipmaps: int, format: int) -> Texture2D
# Factory function for: Texture2D
def texture_cubemap(id: u32, width: int, height: int, mipmaps: int, format: int) -> TextureCubemap
# Factory function for: TextureCubemap
def toggle_fullscreen() -> None
# Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
def transform(translation: Vector3, rotation: Quaternion, scale: Vector3) -> Transform
# Factory function for: Transform
def unload_audio_stream(stream: AudioStream) -> None
# Unload audio stream and free memory
def unload_codepoints(codepoints: Ptr[libs.c.CInt]) -> None
# Unload codepoints data from memory
def unload_directory_files(files: FilePathList) -> None
# Unload filepaths
def unload_dropped_files(files: FilePathList) -> None
# Unload dropped filepaths
def unload_file_data(data: Ptr[libs.c.CUChar]) -> None
# Unload file data allocated by LoadFileData()
def unload_file_text(text: str) -> None
# Unload file text data allocated by LoadFileText()
def unload_font(p_font: Font) -> None
# Unload font from GPU memory (VRAM)
def unload_font_data(chars: Ptr[GlyphInfo], glyph_count: int) -> None
# Unload font chars info data (RAM)
def unload_image(p_image: Image) -> None
# Unload image from CPU memory (RAM)
def unload_image_colors(colors: Ptr[Color]) -> None
# Unload color data loaded with LoadImageColors()
def unload_image_palette(colors: Ptr[Color]) -> None
# Unload colors palette loaded with LoadImagePalette()
def unload_material(material: Material) -> None
# Unload material from GPU memory (VRAM)
def unload_mesh(mesh: Mesh) -> None
# Unload mesh data from CPU and GPU
def unload_model(model: Model) -> None
# Unload model (including meshes) from memory (RAM and/or VRAM)
def unload_model_animation(anim: ModelAnimation) -> None
# Unload animation data
def unload_model_animations(animations: Ptr[ModelAnimation], count: u32) -> None
# Unload animation array data
def unload_music_stream(p_music: Music) -> None
# Unload music stream
def unload_render_texture(target: RenderTexture2D) -> None
# Unload render texture from GPU memory (VRAM)
def unload_shader(shader: Shader) -> None
# Unload shader from GPU memory (VRAM)
def unload_sound(p_sound: Sound) -> None
# Unload sound
def unload_texture(p_texture: Texture2D) -> None
# Unload texture from GPU memory (VRAM)
def unload_utf8(text: str) -> None
# Unload UTF-8 text encoded from codepoints array
def unload_vr_stereo_config(config: VrStereoConfig) -> None
# Unload VR stereo config
def unload_wave(p_wave: Wave) -> None
# Unload wave data
def unload_wave_samples(samples: Ptr[libs.c.CFloat]) -> None
# Unload samples data loaded with LoadWaveSamples()
def update_audio_stream(stream: AudioStream, data: AnyPtrToConst, frame_count: int) -> None
# Update audio stream buffers with data
def update_camera(p_camera: Ptr[Camera], mode: int) -> None
# Update camera position for selected mode
def update_camera_pro(p_camera: Ptr[Camera], movement: Vector3, rotation: Vector3, zoom: float) -> None
# Update camera movement/rotation
def update_mesh_buffer(mesh: Mesh, index: int, data: AnyPtrToConst, data_size: int, offset: int) -> None
# Update mesh vertex data in GPU for a specific buffer index
def update_model_animation(model: Model, anim: ModelAnimation, frame: int) -> None
# Update model animation pose
def update_music_stream(p_music: Music) -> None
# Updates buffers for music streaming
def update_sound(p_sound: Sound, data: AnyPtrToConst, sample_count: int) -> None
# Update sound buffer with new data
def update_texture(p_texture: Texture2D, pixels: AnyPtrToConst) -> None
# Update GPU texture with new data
def update_texture_rec(p_texture: Texture2D, rec: Rectangle, pixels: AnyPtrToConst) -> None
# Update GPU texture rectangle with new data
def upload_mesh(mesh: Ptr[Mesh], dynamic: bool) -> None
# Upload mesh vertex data in GPU and provide VAO/VBO ids
def vector2(x: float, y: float) -> Vector2
# Factory function for: Vector2
def vector3(x: float, y: float, z: float) -> Vector3
# Factory function for: Vector3
def vector4(x: float, y: float, z: float, w: float) -> Vector4
# Factory function for: Vector4
def wait_time(seconds: f64) -> None
# Wait for some time (halt program execution)
def wave(frame_count: u32, sample_rate: u32, sample_size: u32, channels: u32, data: AnyPtr) -> Wave
# Factory function for: Wave
def wave_copy(p_wave: Wave) -> Wave
# Copy a wave to a new wave
def wave_crop(p_wave: Ptr[Wave], init_sample: int, final_sample: int) -> None
# Crop a wave to defined samples range
def wave_format(p_wave: Ptr[Wave], sample_rate: int, sample_size: int, channels: int) -> None
# Convert wave data to desired format
def window_should_close() -> bool
# Check if KEY_ESCAPE pressed or Close icon pressed


# --------------------------------------------------
## raylib.gl
# --------------------------------------------------
RL_ATTACHMENT_COLOR_CHANNEL0: Const[int]
# Framebuffer attachment type: color 0
RL_ATTACHMENT_COLOR_CHANNEL1: Const[int]
# Framebuffer attachment type: color 1
RL_ATTACHMENT_COLOR_CHANNEL2: Const[int]
# Framebuffer attachment type: color 2
RL_ATTACHMENT_COLOR_CHANNEL3: Const[int]
# Framebuffer attachment type: color 3
RL_ATTACHMENT_COLOR_CHANNEL4: Const[int]
# Framebuffer attachment type: color 4
RL_ATTACHMENT_COLOR_CHANNEL5: Const[int]
# Framebuffer attachment type: color 5
RL_ATTACHMENT_COLOR_CHANNEL6: Const[int]
# Framebuffer attachment type: color 6
RL_ATTACHMENT_COLOR_CHANNEL7: Const[int]
# Framebuffer attachment type: color 7
RL_ATTACHMENT_CUBEMAP_NEGATIVE_X: Const[int]
# Framebuffer texture attachment type: cubemap, -X side
RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y: Const[int]
# Framebuffer texture attachment type: cubemap, -Y side
RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z: Const[int]
# Framebuffer texture attachment type: cubemap, -Z side
RL_ATTACHMENT_CUBEMAP_POSITIVE_X: Const[int]
# Framebuffer texture attachment type: cubemap, +X side
RL_ATTACHMENT_CUBEMAP_POSITIVE_Y: Const[int]
# Framebuffer texture attachment type: cubemap, +Y side
RL_ATTACHMENT_CUBEMAP_POSITIVE_Z: Const[int]
# Framebuffer texture attachment type: cubemap, +Z side
RL_ATTACHMENT_DEPTH: Const[int]
# Framebuffer attachment type: depth
RL_ATTACHMENT_RENDERBUFFER: Const[int]
# Framebuffer texture attachment type: renderbuffer
RL_ATTACHMENT_STENCIL: Const[int]
# Framebuffer attachment type: stencil
RL_ATTACHMENT_TEXTURE2D: Const[int]
# Framebuffer texture attachment type: texture2d
RL_BLEND_ADDITIVE: Const[int]
# Blend textures adding colors
RL_BLEND_ADD_COLORS: Const[int]
# Blend textures adding colors (alternative)
RL_BLEND_ALPHA: Const[int]
# Blend textures considering alpha (default)
RL_BLEND_ALPHA_PREMULTIPLY: Const[int]
# Blend premultiplied textures considering alpha
RL_BLEND_CUSTOM: Const[int]
# Blend textures using custom src/dst factors (use rlSetBlendFactors())
RL_BLEND_CUSTOM_SEPARATE: Const[int]
# Blend textures using custom src/dst factors (use rlSetBlendFactorsSeparate())
RL_BLEND_MULTIPLIED: Const[int]
# Blend textures multiplying colors
RL_BLEND_SUBTRACT_COLORS: Const[int]
# Blend textures subtracting colors (alternative)
RL_CULL_FACE_BACK: Const[int]
RL_CULL_FACE_FRONT: Const[int]
RL_LOG_ALL: Const[int]
# Display all logs
RL_LOG_DEBUG: Const[int]
# Debug logging, used for internal debugging, it should be disabled on release builds
RL_LOG_ERROR: Const[int]
# Error logging, used on unrecoverable failures
RL_LOG_FATAL: Const[int]
# Fatal logging, used to abort program: exit(EXIT_FAILURE)
RL_LOG_INFO: Const[int]
# Info logging, used for program execution info
RL_LOG_NONE: Const[int]
# Disable logging
RL_LOG_TRACE: Const[int]
# Trace logging, intended for internal use only
RL_LOG_WARNING: Const[int]
# Warning logging, used on recoverable failures
RL_OPENGL_11: Const[int]
# OpenGL 1.1
RL_OPENGL_21: Const[int]
# OpenGL 2.1 (GLSL 120)
RL_OPENGL_33: Const[int]
# OpenGL 3.3 (GLSL 330)
RL_OPENGL_43: Const[int]
# OpenGL 4.3 (using GLSL 330)
RL_OPENGL_ES_20: Const[int]
# OpenGL ES 2.0 (GLSL 100)
RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: Const[int]
# 8 bpp
RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: Const[int]
# 2 bpp
RL_PIXELFORMAT_COMPRESSED_DXT1_RGB: Const[int]
# 4 bpp (no alpha)
RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA: Const[int]
# 4 bpp (1 bit alpha)
RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA: Const[int]
# 8 bpp
RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA: Const[int]
# 8 bpp
RL_PIXELFORMAT_COMPRESSED_ETC1_RGB: Const[int]
# 4 bpp
RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA: Const[int]
# 8 bpp
RL_PIXELFORMAT_COMPRESSED_ETC2_RGB: Const[int]
# 4 bpp
RL_PIXELFORMAT_COMPRESSED_PVRT_RGB: Const[int]
# 4 bpp
RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA: Const[int]
# 4 bpp
RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: Const[int]
# 8 bit per pixel (no alpha)
RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: Const[int]
# 8*2 bpp (2 channels)
RL_PIXELFORMAT_UNCOMPRESSED_R32: Const[int]
# 32 bpp (1 channel - float)
RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32: Const[int]
# 32*3 bpp (3 channels - float)
RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: Const[int]
# 32*4 bpp (4 channels - float)
RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: Const[int]
# 16 bpp (4 bit alpha)
RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: Const[int]
# 16 bpp (1 bit alpha)
RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5: Const[int]
# 16 bpp
RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8: Const[int]
# 24 bpp
RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: Const[int]
# 32 bpp
RL_SHADER_ATTRIB_FLOAT: Const[int]
# Shader attribute type: float
RL_SHADER_ATTRIB_VEC2: Const[int]
# Shader attribute type: vec2 (2 float)
RL_SHADER_ATTRIB_VEC3: Const[int]
# Shader attribute type: vec3 (3 float)
RL_SHADER_ATTRIB_VEC4: Const[int]
# Shader attribute type: vec4 (4 float)
RL_SHADER_LOC_COLOR_AMBIENT: Const[int]
# Shader location: vector uniform: ambient color
RL_SHADER_LOC_COLOR_DIFFUSE: Const[int]
# Shader location: vector uniform: diffuse color
RL_SHADER_LOC_COLOR_SPECULAR: Const[int]
# Shader location: vector uniform: specular color
RL_SHADER_LOC_MAP_ALBEDO: Const[int]
# Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE)
RL_SHADER_LOC_MAP_BRDF: Const[int]
# Shader location: sampler2d texture: brdf
RL_SHADER_LOC_MAP_CUBEMAP: Const[int]
# Shader location: samplerCube texture: cubemap
RL_SHADER_LOC_MAP_EMISSION: Const[int]
# Shader location: sampler2d texture: emission
RL_SHADER_LOC_MAP_HEIGHT: Const[int]
# Shader location: sampler2d texture: height
RL_SHADER_LOC_MAP_IRRADIANCE: Const[int]
# Shader location: samplerCube texture: irradiance
RL_SHADER_LOC_MAP_METALNESS: Const[int]
# Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR)
RL_SHADER_LOC_MAP_NORMAL: Const[int]
# Shader location: sampler2d texture: normal
RL_SHADER_LOC_MAP_OCCLUSION: Const[int]
# Shader location: sampler2d texture: occlusion
RL_SHADER_LOC_MAP_PREFILTER: Const[int]
# Shader location: samplerCube texture: prefilter
RL_SHADER_LOC_MAP_ROUGHNESS: Const[int]
# Shader location: sampler2d texture: roughness
RL_SHADER_LOC_MATRIX_MODEL: Const[int]
# Shader location: matrix uniform: model (transform)
RL_SHADER_LOC_MATRIX_MVP: Const[int]
# Shader location: matrix uniform: model-view-projection
RL_SHADER_LOC_MATRIX_NORMAL: Const[int]
# Shader location: matrix uniform: normal
RL_SHADER_LOC_MATRIX_PROJECTION: Const[int]
# Shader location: matrix uniform: projection
RL_SHADER_LOC_MATRIX_VIEW: Const[int]
# Shader location: matrix uniform: view (camera transform)
RL_SHADER_LOC_VECTOR_VIEW: Const[int]
# Shader location: vector uniform: view
RL_SHADER_LOC_VERTEX_COLOR: Const[int]
# Shader location: vertex attribute: color
RL_SHADER_LOC_VERTEX_NORMAL: Const[int]
# Shader location: vertex attribute: normal
RL_SHADER_LOC_VERTEX_POSITION: Const[int]
# Shader location: vertex attribute: position
RL_SHADER_LOC_VERTEX_TANGENT: Const[int]
# Shader location: vertex attribute: tangent
RL_SHADER_LOC_VERTEX_TEXCOORD01: Const[int]
# Shader location: vertex attribute: texcoord01
RL_SHADER_LOC_VERTEX_TEXCOORD02: Const[int]
# Shader location: vertex attribute: texcoord02
RL_SHADER_UNIFORM_FLOAT: Const[int]
# Shader uniform type: float
RL_SHADER_UNIFORM_INT: Const[int]
# Shader uniform type: int
RL_SHADER_UNIFORM_IVEC2: Const[int]
# Shader uniform type: ivec2 (2 int)
RL_SHADER_UNIFORM_IVEC3: Const[int]
# Shader uniform type: ivec3 (3 int)
RL_SHADER_UNIFORM_IVEC4: Const[int]
# Shader uniform type: ivec4 (4 int)
RL_SHADER_UNIFORM_SAMPLER2D: Const[int]
# Shader uniform type: sampler2d
RL_SHADER_UNIFORM_VEC2: Const[int]
# Shader uniform type: vec2 (2 float)
RL_SHADER_UNIFORM_VEC3: Const[int]
# Shader uniform type: vec3 (3 float)
RL_SHADER_UNIFORM_VEC4: Const[int]
# Shader uniform type: vec4 (4 float)
RL_TEXTURE_FILTER_ANISOTROPIC_16X: Const[int]
# Anisotropic filtering 16x
RL_TEXTURE_FILTER_ANISOTROPIC_4X: Const[int]
# Anisotropic filtering 4x
RL_TEXTURE_FILTER_ANISOTROPIC_8X: Const[int]
# Anisotropic filtering 8x
RL_TEXTURE_FILTER_BILINEAR: Const[int]
# Linear filtering
RL_TEXTURE_FILTER_POINT: Const[int]
# No filter, just pixel approximation
RL_TEXTURE_FILTER_TRILINEAR: Const[int]
# Trilinear filtering (linear with mipmaps)
class rlDrawCall
# of those state-change happens (this is done in core module): 
    mode: libs.c.CInt
    vertexCount: libs.c.CInt
    vertexAlignment: libs.c.CInt
    textureId: libs.c.CUInt
class rlRenderBatch
# rlRenderBatch type: 
    bufferCount: libs.c.CInt
    currentBuffer: libs.c.CInt
    vertexBuffer: Ptr[raylib.rlVertexBuffer]
    draws: Ptr[raylib.rlDrawCall]
    drawCounter: libs.c.CInt
    currentDepth: float
class rlVertexBuffer
# Dynamic vertex buffers (position + texcoords + colors + indices arrays)
class rlglData
def rl_active_draw_buffers(count: int) -> None
# Activate multiple draw color buffers
def rl_active_texture_slot(slot: int) -> None
# Select and active a texture slot
def rl_begin(mode: int) -> None
# Initialize drawing mode (how to organize vertex)
def rl_bind_image_texture(id: u32, index: u32, format: int, readonly: bool) -> None
# Bind image texture
def rl_bind_shader_buffer(id: u32, index: u32) -> None
# Bind SSBO buffer
def rl_check_errors() -> None
# Check and log OpenGL error codes
def rl_check_render_batch_limit(v_count: int) -> bool
# Check internal buffer overflow for a given number of vertex
def rl_clear_color(r: int, g: int, b: int, a: int) -> None
# Clear color buffer with color
def rl_clear_screen_buffers() -> None
# Clear used screen buffers (color and depth)
def rl_color3f(x: float, y: float, z: float) -> None
# Define one vertex (color) - 3 float
def rl_color4f(x: float, y: float, z: float, w: float) -> None
# Define one vertex (color) - 4 float
def rl_color4ub(r: int, g: int, b: int, a: int) -> None
# Define one vertex (color) - 4 byte
def rl_compile_shader(shader_code: str, type: int) -> u32
# Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
def rl_compute_shader_dispatch(group_x: u32, group_y: u32, group_z: u32) -> None
# Dispatch compute shader (equivalent to *draw* for graphics pipeline)
def rl_copy_shader_buffer(dest_id: u32, src_id: u32, dest_offset: u32, src_offset: u32, count: u32) -> None
# Copy SSBO data between buffers
def rl_cubemap_parameters(id: u32, param: int, value: int) -> None
# Set cubemap parameters (filter, wrap)
def rl_disable_backface_culling() -> None
# Disable backface culling
def rl_disable_color_blend() -> None
# Disable color blending
def rl_disable_depth_mask() -> None
# Disable depth write
def rl_disable_depth_test() -> None
# Disable depth test
def rl_disable_framebuffer() -> None
# Disable render texture (fbo), return to default framebuffer
def rl_disable_scissor_test() -> None
# Disable scissor test
def rl_disable_shader() -> None
# Disable shader program
def rl_disable_smooth_lines() -> None
# Disable line aliasing
def rl_disable_state_pointer(vertex_attrib_type: int) -> None
# Disable attribute state pointer
def rl_disable_stereo_render() -> None
# Disable stereo rendering
def rl_disable_texture() -> None
# Disable texture
def rl_disable_texture_cubemap() -> None
# Disable texture cubemap
def rl_disable_vertex_array() -> None
# Disable vertex array (VAO, if supported)
def rl_disable_vertex_attribute(index: u32) -> None
# Disable vertex attribute index
def rl_disable_vertex_buffer() -> None
# Disable vertex buffer (VBO)
def rl_disable_vertex_buffer_element() -> None
# Disable vertex buffer element (VBO element)
def rl_disable_wire_mode() -> None
# Disable wire mode
def rl_draw_call(mode: int, vertex_count: int, vertex_alignment: int, texture_id: u32) -> rlDrawCall
# Factory function for: rlDrawCall
def rl_draw_render_batch(batch: Ptr[raylib.rlRenderBatch]) -> None
# Draw render batch data (Update->Draw->Reset)
def rl_draw_render_batch_active() -> None
# Update and draw internal render batch
def rl_draw_vertex_array(offset: int, count: int) -> None
def rl_draw_vertex_array_elements(offset: int, count: int, buffer: AnyPtrToConst) -> None
def rl_draw_vertex_array_elements_instanced(offset: int, count: int, buffer: AnyPtrToConst, instances: int) -> None
def rl_draw_vertex_array_instanced(offset: int, count: int, instances: int) -> None
def rl_enable_backface_culling() -> None
# Enable backface culling
def rl_enable_color_blend() -> None
# Enable color blending
def rl_enable_depth_mask() -> None
# Enable depth write
def rl_enable_depth_test() -> None
# Enable depth test
def rl_enable_framebuffer(id: u32) -> None
# Enable render texture (fbo)
def rl_enable_scissor_test() -> None
# Enable scissor test
def rl_enable_shader(id: u32) -> None
# Enable shader program
def rl_enable_smooth_lines() -> None
# Enable line aliasing
def rl_enable_state_pointer(vertex_attrib_type: int, buffer: AnyPtr) -> None
# Enable attribute state pointer
def rl_enable_stereo_render() -> None
# Enable stereo rendering
def rl_enable_texture(id: u32) -> None
# Enable texture
def rl_enable_texture_cubemap(id: u32) -> None
# Enable texture cubemap
def rl_enable_vertex_array(vao_id: u32) -> bool
# Enable vertex array (VAO, if supported)
def rl_enable_vertex_attribute(index: u32) -> None
# Enable vertex attribute index
def rl_enable_vertex_buffer(id: u32) -> None
# Enable vertex buffer (VBO)
def rl_enable_vertex_buffer_element(id: u32) -> None
# Enable vertex buffer element (VBO element)
def rl_enable_wire_mode() -> None
# Enable wire mode
def rl_end() -> None
# Finish vertex providing
def rl_framebuffer_attach(fbo_id: u32, tex_id: u32, attach_type: int, tex_type: int, mip_level: int) -> None
# Attach texture/renderbuffer to a framebuffer
def rl_framebuffer_complete(id: u32) -> bool
# Verify framebuffer is complete
def rl_frustum(left: f64, right: f64, bottom: f64, top: f64, znear: f64, zfar: f64) -> None
def rl_gen_texture_mipmaps(id: u32, width: int, height: int, format: int, mipmaps: Ptr[libs.c.CInt]) -> None
# Generate mipmap data for selected texture
def rl_get_framebuffer_height() -> int
# Get default framebuffer height
def rl_get_framebuffer_width() -> int
# Get default framebuffer width
def rl_get_gl_texture_formats(format: int, gl_internal_format: Ptr[libs.c.CUInt], gl_format: Ptr[libs.c.CUInt], gl_type: Ptr[libs.c.CUInt]) -> None
# Get OpenGL internal formats
def rl_get_line_width() -> float
# Get the line drawing width
def rl_get_location_attrib(shader_id: u32, attrib_name: str) -> int
# Get shader location attribute
def rl_get_location_uniform(shader_id: u32, uniform_name: str) -> int
# Get shader location uniform
def rl_get_matrix_modelview() -> raylib.Matrix
# Get internal modelview matrix
def rl_get_matrix_projection() -> raylib.Matrix
# Get internal projection matrix
def rl_get_matrix_projection_stereo(eye: int) -> raylib.Matrix
# Get internal projection matrix for stereo render (selected eye)
def rl_get_matrix_transform() -> raylib.Matrix
# Get internal accumulated transform matrix
def rl_get_matrix_view_offset_stereo(eye: int) -> raylib.Matrix
# Get internal view offset matrix for stereo render (selected eye)
def rl_get_pixel_format_name(format: u32) -> Ptr[Const[libs.c.CChar]]
# Get name string for pixel format
def rl_get_shader_buffer_size(id: u32) -> u32
# Get SSBO buffer size
def rl_get_shader_id_default() -> u32
# Get default shader id
def rl_get_shader_locs_default() -> Ptr[libs.c.CInt]
# Get default shader locations
def rl_get_texture_id_default() -> u32
# Get default texture id
def rl_get_version() -> int
# Get current OpenGL version
def rl_is_stereo_render_enabled() -> bool
# Check if stereo render is enabled
def rl_load_compute_shader_program(shader_id: u32) -> u32
# Load compute shader program
def rl_load_draw_cube() -> None
# Load and draw a cube
def rl_load_draw_quad() -> None
# Load and draw a quad
def rl_load_extensions(loader: AnyPtr) -> None
# Load OpenGL extensions (loader function required)
def rl_load_framebuffer(width: int, height: int) -> u32
# Load an empty framebuffer
def rl_load_identity() -> None
# Reset current matrix to identity matrix
def rl_load_render_batch(num_buffers: int, buffer_elements: int) -> raylib.rlRenderBatch
# Load a render batch system
def rl_load_shader_buffer(size: u32, data: AnyPtrToConst, usage_hint: int) -> u32
# Load shader storage buffer object (SSBO)
def rl_load_shader_code(vs_code: str, fs_code: str) -> u32
# Load shader from code strings
def rl_load_shader_program(v_shader_id: u32, f_shader_id: u32) -> u32
# Load custom shader program
def rl_load_texture(data: AnyPtrToConst, width: int, height: int, format: int, mipmap_count: int) -> u32
# Load texture in GPU
def rl_load_texture_cubemap(data: AnyPtrToConst, size: int, format: int) -> u32
# Load texture cubemap
def rl_load_texture_depth(width: int, height: int, use_render_buffer: bool) -> u32
# Load depth texture/renderbuffer (to be attached to fbo)
def rl_load_vertex_array() -> u32
# Load vertex array (vao) if supported
def rl_load_vertex_buffer(buffer: AnyPtrToConst, size: int, dynamic: bool) -> u32
# Load a vertex buffer attribute
def rl_load_vertex_buffer_element(buffer: AnyPtrToConst, size: int, dynamic: bool) -> u32
# Load a new attributes element buffer
def rl_matrix_mode(mode: int) -> None
# Choose the current matrix to be transformed
def rl_normal3f(x: float, y: float, z: float) -> None
# Define one vertex (normal) - 3 float
def rl_ortho(left: f64, right: f64, bottom: f64, top: f64, znear: f64, zfar: f64) -> None
def rl_pop_matrix() -> None
# Pop latest inserted matrix from stack
def rl_push_matrix() -> None
# Push the current matrix to stack
def rl_read_screen_pixels(width: int, height: int) -> Ptr[libs.c.CUChar]
# Read screen pixel data (color buffer)
def rl_read_shader_buffer(id: u32, dest: AnyPtr, count: u32, offset: u32) -> None
# Read SSBO buffer data (GPU->CPU)
def rl_read_texture_pixels(id: u32, width: int, height: int, format: int) -> AnyPtr
# Read texture pixel data
def rl_render_batch(buffer_count: int, current_buffer: int, vertex_buffer: Ptr[raylib.rlVertexBuffer], draws: Ptr[raylib.rlDrawCall], draw_counter: int, current_depth: float) -> rlRenderBatch
# Factory function for: rlRenderBatch
def rl_rotatef(angle: float, x: float, y: float, z: float) -> None
# Multiply the current matrix by a rotation matrix
def rl_scalef(x: float, y: float, z: float) -> None
# Multiply the current matrix by a scaling matrix
def rl_scissor(x: int, y: int, width: int, height: int) -> None
# Scissor test
def rl_set_blend_factors(gl_src_factor: int, gl_dst_factor: int, gl_equation: int) -> None
# Set blending mode factor and equation (using OpenGL factors)
def rl_set_blend_factors_separate(gl_src_rgb: int, gl_dst_rgb: int, gl_src_alpha: int, gl_dst_alpha: int, gl_eq_rgb: int, gl_eq_alpha: int) -> None
# Set blending mode factors and equations separately (using OpenGL factors)
def rl_set_blend_mode(mode: int) -> None
# Set blending mode
def rl_set_cull_face(mode: int) -> None
# Set face culling mode
def rl_set_framebuffer_height(height: int) -> None
# Set current framebuffer height
def rl_set_framebuffer_width(width: int) -> None
# Set current framebuffer width
def rl_set_line_width(width: float) -> None
# Set the line drawing width
def rl_set_matrix_modelview(view: raylib.Matrix) -> None
# Set a custom modelview matrix (replaces internal modelview matrix)
def rl_set_matrix_projection(proj: raylib.Matrix) -> None
# Set a custom projection matrix (replaces internal projection matrix)
def rl_set_matrix_projection_stereo(right: raylib.Matrix, left: raylib.Matrix) -> None
# Set eyes projection matrices for stereo rendering
def rl_set_matrix_view_offset_stereo(right: raylib.Matrix, left: raylib.Matrix) -> None
# Set eyes view offsets matrices for stereo rendering
def rl_set_render_batch_active(batch: Ptr[raylib.rlRenderBatch]) -> None
# Set the active render batch for rlgl (NULL for default internal)
def rl_set_shader(id: u32, locs: Ptr[libs.c.CInt]) -> None
# Set shader currently active (id and locations)
def rl_set_texture(id: u32) -> None
# Set current texture for render batch and check buffers limits
def rl_set_uniform(loc_index: int, value: AnyPtrToConst, uniform_type: int, count: int) -> None
# Set shader value uniform
def rl_set_uniform_matrix(loc_index: int, mat: raylib.Matrix) -> None
# Set shader value matrix
def rl_set_uniform_sampler(loc_index: int, texture_id: u32) -> None
# Set shader value sampler
def rl_set_vertex_attribute(index: u32, comp_size: int, type: int, normalized: bool, stride: int, pointer: AnyPtrToConst) -> None
def rl_set_vertex_attribute_default(loc_index: int, value: AnyPtrToConst, attrib_type: int, count: int) -> None
# Set vertex attribute default value
def rl_set_vertex_attribute_divisor(index: u32, divisor: int) -> None
def rl_tex_coord2f(x: float, y: float) -> None
# Define one vertex (texture coordinate) - 2 float
def rl_texture_parameters(id: u32, param: int, value: int) -> None
# Set texture parameters (filter, wrap)
def rl_translatef(x: float, y: float, z: float) -> None
# Multiply the current matrix by a translation matrix
def rl_unload_framebuffer(id: u32) -> None
# Delete framebuffer from GPU
def rl_unload_render_batch(batch: raylib.rlRenderBatch) -> None
# Unload render batch system
def rl_unload_shader_buffer(ssbo_id: u32) -> None
# Unload shader storage buffer object (SSBO)
def rl_unload_shader_program(id: u32) -> None
# Unload shader program
def rl_unload_texture(id: u32) -> None
# Unload texture from GPU memory
def rl_unload_vertex_array(vao_id: u32) -> None
def rl_unload_vertex_buffer(vbo_id: u32) -> None
def rl_update_shader_buffer(id: u32, data: AnyPtrToConst, data_size: u32, offset: u32) -> None
# Update SSBO buffer data
def rl_update_texture(id: u32, offset_x: int, offset_y: int, width: int, height: int, format: int, data: AnyPtrToConst) -> None
# Update GPU texture with new data
def rl_update_vertex_buffer(buffer_id: u32, data: AnyPtrToConst, data_size: int, offset: int) -> None
# Update GPU buffer with new data
def rl_update_vertex_buffer_elements(id: u32, data: AnyPtrToConst, data_size: int, offset: int) -> None
# Update vertex buffer elements with new data
def rl_vertex2f(x: float, y: float) -> None
# Define one vertex (position) - 2 float
def rl_vertex2i(x: int, y: int) -> None
# Define one vertex (position) - 2 int
def rl_vertex3f(x: float, y: float, z: float) -> None
# Define one vertex (position) - 3 float
def rl_viewport(x: int, y: int, width: int, height: int) -> None
# Set the viewport area
def rlgl_close() -> None
# De-initialize rlgl (buffers, shaders, textures)
def rlgl_init(width: int, height: int) -> None
# Initialize rlgl (buffers, shaders, textures, states)


# --------------------------------------------------
## raylib.gui
# --------------------------------------------------
ARROWS_SIZE: Const[int]
ARROWS_VISIBLE: Const[int]
ARROW_PADDING: Const[int]
# DropdownBox arrow separation from border and items
BACKGROUND_COLOR: Const[int]
# Background color
BASE_COLOR_DISABLED: Const[int]
BASE_COLOR_FOCUSED: Const[int]
BASE_COLOR_NORMAL: Const[int]
BASE_COLOR_PRESSED: Const[int]
BORDER_COLOR_DISABLED: Const[int]
BORDER_COLOR_FOCUSED: Const[int]
BORDER_COLOR_NORMAL: Const[int]
BORDER_COLOR_PRESSED: Const[int]
BORDER_WIDTH: Const[int]
BUTTON: Const[int]
CHECKBOX: Const[int]
CHECK_PADDING: Const[int]
# CheckBox internal check padding
COLORPICKER: Const[int]
COLOR_SELECTOR_SIZE: Const[int]
COMBOBOX: Const[int]
COMBO_BUTTON_SPACING: Const[int]
# ComboBox button separation
COMBO_BUTTON_WIDTH: Const[int]
# ComboBox right button width
DEFAULT: Const[int]
DROPDOWNBOX: Const[int]
DROPDOWN_ITEMS_SPACING: Const[int]
# DropdownBox items separation
GROUP_PADDING: Const[int]
# ToggleGroup separation between toggles
HUEBAR_PADDING: Const[int]
# ColorPicker right hue bar separation from panel
HUEBAR_SELECTOR_HEIGHT: Const[int]
# ColorPicker right hue bar selector height
HUEBAR_SELECTOR_OVERFLOW: Const[int]
# ColorPicker right hue bar selector overflow
HUEBAR_WIDTH: Const[int]
# ColorPicker right hue bar width
ICON_1UP: Const[int]
ICON_219: Const[int]
ICON_220: Const[int]
ICON_221: Const[int]
ICON_222: Const[int]
ICON_223: Const[int]
ICON_224: Const[int]
ICON_225: Const[int]
ICON_226: Const[int]
ICON_227: Const[int]
ICON_228: Const[int]
ICON_229: Const[int]
ICON_230: Const[int]
ICON_231: Const[int]
ICON_232: Const[int]
ICON_233: Const[int]
ICON_234: Const[int]
ICON_235: Const[int]
ICON_236: Const[int]
ICON_237: Const[int]
ICON_238: Const[int]
ICON_239: Const[int]
ICON_240: Const[int]
ICON_241: Const[int]
ICON_242: Const[int]
ICON_243: Const[int]
ICON_244: Const[int]
ICON_245: Const[int]
ICON_246: Const[int]
ICON_247: Const[int]
ICON_248: Const[int]
ICON_249: Const[int]
ICON_250: Const[int]
ICON_251: Const[int]
ICON_252: Const[int]
ICON_253: Const[int]
ICON_254: Const[int]
ICON_255: Const[int]
ICON_ALARM: Const[int]
ICON_ALPHA_CLEAR: Const[int]
ICON_ALPHA_MULTIPLY: Const[int]
ICON_ARROW_DOWN: Const[int]
ICON_ARROW_DOWN_FILL: Const[int]
ICON_ARROW_LEFT: Const[int]
ICON_ARROW_LEFT_FILL: Const[int]
ICON_ARROW_RIGHT: Const[int]
ICON_ARROW_RIGHT_FILL: Const[int]
ICON_ARROW_UP: Const[int]
ICON_ARROW_UP_FILL: Const[int]
ICON_AUDIO: Const[int]
ICON_BIN: Const[int]
ICON_BOX: Const[int]
ICON_BOX_BOTTOM: Const[int]
ICON_BOX_BOTTOM_LEFT: Const[int]
ICON_BOX_BOTTOM_RIGHT: Const[int]
ICON_BOX_CENTER: Const[int]
ICON_BOX_CIRCLE_MASK: Const[int]
ICON_BOX_CONCENTRIC: Const[int]
ICON_BOX_CORNERS_BIG: Const[int]
ICON_BOX_CORNERS_SMALL: Const[int]
ICON_BOX_DOTS_BIG: Const[int]
ICON_BOX_DOTS_SMALL: Const[int]
ICON_BOX_GRID: Const[int]
ICON_BOX_GRID_BIG: Const[int]
ICON_BOX_LEFT: Const[int]
ICON_BOX_MULTISIZE: Const[int]
ICON_BOX_RIGHT: Const[int]
ICON_BOX_TOP: Const[int]
ICON_BOX_TOP_LEFT: Const[int]
ICON_BOX_TOP_RIGHT: Const[int]
ICON_BREAKPOINT_OFF: Const[int]
ICON_BREAKPOINT_ON: Const[int]
ICON_BRUSH_CLASSIC: Const[int]
ICON_BRUSH_PAINTER: Const[int]
ICON_BURGER_MENU: Const[int]
ICON_CAMERA: Const[int]
ICON_CASE_SENSITIVE: Const[int]
ICON_CLOCK: Const[int]
ICON_COIN: Const[int]
ICON_COLOR_BUCKET: Const[int]
ICON_COLOR_PICKER: Const[int]
ICON_CORNER: Const[int]
ICON_CPU: Const[int]
ICON_CRACK: Const[int]
ICON_CRACK_POINTS: Const[int]
ICON_CROP: Const[int]
ICON_CROP_ALPHA: Const[int]
ICON_CROSS: Const[int]
ICON_CROSSLINE: Const[int]
ICON_CROSS_SMALL: Const[int]
ICON_CUBE: Const[int]
ICON_CUBE_FACE_BACK: Const[int]
ICON_CUBE_FACE_BOTTOM: Const[int]
ICON_CUBE_FACE_FRONT: Const[int]
ICON_CUBE_FACE_LEFT: Const[int]
ICON_CUBE_FACE_RIGHT: Const[int]
ICON_CUBE_FACE_TOP: Const[int]
ICON_CURSOR_CLASSIC: Const[int]
ICON_CURSOR_HAND: Const[int]
ICON_CURSOR_MOVE: Const[int]
ICON_CURSOR_MOVE_FILL: Const[int]
ICON_CURSOR_POINTER: Const[int]
ICON_CURSOR_SCALE: Const[int]
ICON_CURSOR_SCALE_FILL: Const[int]
ICON_CURSOR_SCALE_LEFT: Const[int]
ICON_CURSOR_SCALE_LEFT_FILL: Const[int]
ICON_CURSOR_SCALE_RIGHT: Const[int]
ICON_CURSOR_SCALE_RIGHT_FILL: Const[int]
ICON_DEMON: Const[int]
ICON_DITHERING: Const[int]
ICON_DOOR: Const[int]
ICON_EMPTYBOX: Const[int]
ICON_EMPTYBOX_SMALL: Const[int]
ICON_EXIT: Const[int]
ICON_EXPLOSION: Const[int]
ICON_EYE_OFF: Const[int]
ICON_EYE_ON: Const[int]
ICON_FILE: Const[int]
ICON_FILETYPE_ALPHA: Const[int]
ICON_FILETYPE_AUDIO: Const[int]
ICON_FILETYPE_BINARY: Const[int]
ICON_FILETYPE_HOME: Const[int]
ICON_FILETYPE_IMAGE: Const[int]
ICON_FILETYPE_INFO: Const[int]
ICON_FILETYPE_PLAY: Const[int]
ICON_FILETYPE_TEXT: Const[int]
ICON_FILETYPE_VIDEO: Const[int]
ICON_FILE_ADD: Const[int]
ICON_FILE_COPY: Const[int]
ICON_FILE_CUT: Const[int]
ICON_FILE_DELETE: Const[int]
ICON_FILE_EXPORT: Const[int]
ICON_FILE_NEW: Const[int]
ICON_FILE_OPEN: Const[int]
ICON_FILE_PASTE: Const[int]
ICON_FILE_SAVE: Const[int]
ICON_FILE_SAVE_CLASSIC: Const[int]
ICON_FILTER: Const[int]
ICON_FILTER_BILINEAR: Const[int]
ICON_FILTER_POINT: Const[int]
ICON_FILTER_TOP: Const[int]
ICON_FOLDER: Const[int]
ICON_FOLDER_ADD: Const[int]
ICON_FOLDER_FILE_OPEN: Const[int]
ICON_FOLDER_OPEN: Const[int]
ICON_FOLDER_SAVE: Const[int]
ICON_FOUR_BOXES: Const[int]
ICON_FX: Const[int]
ICON_GEAR: Const[int]
ICON_GEAR_BIG: Const[int]
ICON_GEAR_EX: Const[int]
ICON_GRID: Const[int]
ICON_GRID_FILL: Const[int]
ICON_HAND_POINTER: Const[int]
ICON_HEART: Const[int]
ICON_HELP: Const[int]
ICON_HEX: Const[int]
ICON_HIDPI: Const[int]
ICON_HOUSE: Const[int]
ICON_INFO: Const[int]
ICON_KEY: Const[int]
ICON_LASER: Const[int]
ICON_LAYERS: Const[int]
ICON_LAYERS_VISIBLE: Const[int]
ICON_LENS: Const[int]
ICON_LENS_BIG: Const[int]
ICON_LIFE_BARS: Const[int]
ICON_LINK: Const[int]
ICON_LINK_BOXES: Const[int]
ICON_LINK_BROKE: Const[int]
ICON_LINK_MULTI: Const[int]
ICON_LINK_NET: Const[int]
ICON_LOCK_CLOSE: Const[int]
ICON_LOCK_OPEN: Const[int]
ICON_MAGNET: Const[int]
ICON_MAILBOX: Const[int]
ICON_MIPMAPS: Const[int]
ICON_MODE_2D: Const[int]
ICON_MODE_3D: Const[int]
ICON_MONITOR: Const[int]
ICON_MUTATE: Const[int]
ICON_MUTATE_FILL: Const[int]
ICON_NONE: Const[int]
ICON_NOTEBOOK: Const[int]
ICON_OK_TICK: Const[int]
ICON_PENCIL: Const[int]
ICON_PENCIL_BIG: Const[int]
ICON_PHOTO_CAMERA: Const[int]
ICON_PHOTO_CAMERA_FLASH: Const[int]
ICON_PLAYER: Const[int]
ICON_PLAYER_JUMP: Const[int]
ICON_PLAYER_NEXT: Const[int]
ICON_PLAYER_PAUSE: Const[int]
ICON_PLAYER_PLAY: Const[int]
ICON_PLAYER_PLAY_BACK: Const[int]
ICON_PLAYER_PREVIOUS: Const[int]
ICON_PLAYER_RECORD: Const[int]
ICON_PLAYER_STOP: Const[int]
ICON_POT: Const[int]
ICON_PRINTER: Const[int]
ICON_REDO: Const[int]
ICON_REDO_FILL: Const[int]
ICON_REG_EXP: Const[int]
ICON_REPEAT: Const[int]
ICON_REPEAT_FILL: Const[int]
ICON_REREDO: Const[int]
ICON_REREDO_FILL: Const[int]
ICON_RESIZE: Const[int]
ICON_RESTART: Const[int]
ICON_ROM: Const[int]
ICON_ROTATE: Const[int]
ICON_ROTATE_FILL: Const[int]
ICON_RUBBER: Const[int]
ICON_SCALE: Const[int]
ICON_SHIELD: Const[int]
ICON_SHUFFLE: Const[int]
ICON_SHUFFLE_FILL: Const[int]
ICON_SPECIAL: Const[int]
ICON_SQUARE_TOGGLE: Const[int]
ICON_STAR: Const[int]
ICON_STEP_INTO: Const[int]
ICON_STEP_OUT: Const[int]
ICON_STEP_OVER: Const[int]
ICON_SUITCASE: Const[int]
ICON_SUITCASE_ZIP: Const[int]
ICON_SYMMETRY: Const[int]
ICON_SYMMETRY_HORIZONTAL: Const[int]
ICON_SYMMETRY_VERTICAL: Const[int]
ICON_TARGET: Const[int]
ICON_TARGET_BIG: Const[int]
ICON_TARGET_BIG_FILL: Const[int]
ICON_TARGET_MOVE: Const[int]
ICON_TARGET_MOVE_FILL: Const[int]
ICON_TARGET_POINT: Const[int]
ICON_TARGET_SMALL: Const[int]
ICON_TARGET_SMALL_FILL: Const[int]
ICON_TEXT_A: Const[int]
ICON_TEXT_NOTES: Const[int]
ICON_TEXT_POPUP: Const[int]
ICON_TEXT_T: Const[int]
ICON_TOOLS: Const[int]
ICON_UNDO: Const[int]
ICON_UNDO_FILL: Const[int]
ICON_VERTICAL_BARS: Const[int]
ICON_VERTICAL_BARS_FILL: Const[int]
ICON_WATER_DROP: Const[int]
ICON_WAVE: Const[int]
ICON_WAVE_SINUS: Const[int]
ICON_WAVE_SQUARE: Const[int]
ICON_WAVE_TRIANGULAR: Const[int]
ICON_WINDOW: Const[int]
ICON_ZOOM_ALL: Const[int]
ICON_ZOOM_BIG: Const[int]
ICON_ZOOM_CENTER: Const[int]
ICON_ZOOM_MEDIUM: Const[int]
ICON_ZOOM_SMALL: Const[int]
LABEL: Const[int]
# Used also for: LABELBUTTON
LINE_COLOR: Const[int]
# Line control color
LISTVIEW: Const[int]
LIST_ITEMS_HEIGHT: Const[int]
# ListView items height
LIST_ITEMS_SPACING: Const[int]
# ListView items separation
PROGRESSBAR: Const[int]
PROGRESS_PADDING: Const[int]
# ProgressBar internal padding
RESERVED: Const[int]
SCROLLBAR: Const[int]
SCROLLBAR_SIDE: Const[int]
# ListView scrollbar side (0-left, 1-right)
SCROLLBAR_WIDTH: Const[int]
# ListView scrollbar size (usually width)
SCROLL_PADDING: Const[int]
SCROLL_SLIDER_PADDING: Const[int]
# (SLIDERBAR, SLIDER_PADDING)
SCROLL_SLIDER_SIZE: Const[int]
SCROLL_SPEED: Const[int]
SLIDER: Const[int]
# Used also for: SLIDERBAR
SLIDER_PADDING: Const[int]
# Slider/SliderBar internal bar padding
SLIDER_WIDTH: Const[int]
# Slider size of internal bar
SPINNER: Const[int]
# Uses: BUTTON, VALUEBOX
SPIN_BUTTON_SPACING: Const[int]
# Spinner buttons separation
SPIN_BUTTON_WIDTH: Const[int]
# Spinner left/right buttons width
STATE_DISABLED: Const[int]
STATE_FOCUSED: Const[int]
STATE_NORMAL: Const[int]
STATE_PRESSED: Const[int]
STATUSBAR: Const[int]
TEXTBOX: Const[int]
# Used also for: TEXTBOXMULTI
TEXT_ALIGNMENT: Const[int]
TEXT_ALIGN_CENTER: Const[int]
TEXT_ALIGN_LEFT: Const[int]
TEXT_ALIGN_RIGHT: Const[int]
TEXT_COLOR_DISABLED: Const[int]
TEXT_COLOR_FOCUSED: Const[int]
TEXT_COLOR_NORMAL: Const[int]
TEXT_COLOR_PRESSED: Const[int]
TEXT_INNER_PADDING: Const[int]
# TextBox/TextBoxMulti/ValueBox/Spinner inner text padding
TEXT_LINES_SPACING: Const[int]
# TextBoxMulti lines separation
TEXT_PADDING: Const[int]
TEXT_SIZE: Const[int]
# Text size (glyphs max height)
TEXT_SPACING: Const[int]
# Text spacing between glyphs
TOGGLE: Const[int]
# Used also for: TOGGLEGROUP
VALUEBOX: Const[int]
class GuiStyleProp
# Style property: 
    controlId: libs.c.CUShort
    propertyId: libs.c.CUShort
    propertyValue: libs.c.CUInt
def gui_button(bounds: raylib.Rectangle, text: str) -> bool
# Button control, returns true when clicked
def gui_check_box(bounds: raylib.Rectangle, text: str, checked: bool) -> bool
# Check Box control, returns true when active
def gui_color_bar_alpha(bounds: raylib.Rectangle, text: str, alpha: float) -> float
# Color Bar Alpha control
def gui_color_bar_hue(bounds: raylib.Rectangle, text: str, value: float) -> float
# Color Bar Hue control
def gui_color_panel(bounds: raylib.Rectangle, text: str, p_color: raylib.Color) -> raylib.Color
# Color Panel control
def gui_color_picker(bounds: raylib.Rectangle, text: str, p_color: raylib.Color) -> raylib.Color
# Color Picker control (multiple color controls)
def gui_combo_box(bounds: raylib.Rectangle, text: str, active: int) -> int
# Combo Box control, returns selected item index
def gui_disable() -> None
# Disable gui controls (global state)
def gui_disable_tooltip() -> None
# Disable gui tooltips (global state)
def gui_draw_icon(icon_id: int, pos_x: int, pos_y: int, pixel_size: int, p_color: raylib.Color) -> None
def gui_dropdown_box(bounds: raylib.Rectangle, text: str, active: Ptr[libs.c.CInt], edit_mode: bool) -> bool
# Dropdown Box control, returns selected item
def gui_dummy_rec(bounds: raylib.Rectangle, text: str) -> None
# Dummy control for placeholders
def gui_enable() -> None
# Enable gui controls (global state)
def gui_enable_tooltip() -> None
# Enable gui tooltips (global state)
def gui_fade(alpha: float) -> None
# Set gui controls alpha (global state), alpha goes from 0.0f to 1.0f
def gui_get_font() -> raylib.Font
# Get gui custom font (global state)
def gui_get_icons() -> Ptr[libs.c.CUInt]
# Get raygui icons data pointer
def gui_get_state() -> int
# Get gui state (global state)
def gui_get_style(control: int, property: int) -> int
# Get one style property
def gui_grid(bounds: raylib.Rectangle, text: str, spacing: float, subdivs: int) -> raylib.Vector2
# Grid control, returns mouse cell position
def gui_group_box(bounds: raylib.Rectangle, text: str) -> None
# Group Box control with text name
def gui_icon_text(icon_id: int, text: str) -> Ptr[Const[libs.c.CChar]]
# Get text with icon id prepended (if supported)
def gui_is_locked() -> bool
# Check if gui is locked (global state)
def gui_label(bounds: raylib.Rectangle, text: str) -> None
# Label control, shows text
def gui_label_button(bounds: raylib.Rectangle, text: str) -> bool
# Label button control, show true when clicked
def gui_line(bounds: raylib.Rectangle, text: str) -> None
# Line separator control, could contain text
def gui_list_view(bounds: raylib.Rectangle, text: str, scroll_index: Ptr[libs.c.CInt], active: int) -> int
# List View control, returns selected list item index
def gui_list_view_ex(bounds: raylib.Rectangle, text: Ptr[Ptr[Const[libs.c.CChar]]], count: int, focus: Ptr[libs.c.CInt], scroll_index: Ptr[libs.c.CInt], active: int) -> int
# List View with extended parameters
def gui_load_icons(file_name: str, load_icons_name: bool) -> Ptr[Ptr[libs.c.CChar]]
# Load raygui icons file (.rgi) into internal icons data
def gui_load_style(file_name: str) -> None
# Load style file over global style variable (.rgs)
def gui_load_style_default() -> None
# Load style default over global style
def gui_lock() -> None
# Lock gui controls (global state)
def gui_message_box(bounds: raylib.Rectangle, title: str, message: str, buttons: str) -> int
# Message Box control, displays a message
def gui_panel(bounds: raylib.Rectangle, text: str) -> None
# Panel control, useful to group controls
def gui_progress_bar(bounds: raylib.Rectangle, text_left: str, text_right: str, value: float, min_value: float, max_value: float) -> float
# Progress Bar control, shows current progress value
def gui_scroll_panel(bounds: raylib.Rectangle, text: str, content: raylib.Rectangle, scroll: Ptr[raylib.Vector2]) -> raylib.Rectangle
# Scroll Panel control
def gui_set_font(p_font: raylib.Font) -> None
# Set gui custom font (global state)
def gui_set_icon_scale(scale: int) -> None
# Set icon drawing size
def gui_set_state(state: int) -> None
# Set gui state (global state)
def gui_set_style(control: int, property: int, value: int) -> None
# Set one style property
def gui_set_tooltip(tooltip: str) -> None
# Set tooltip string
def gui_slider(bounds: raylib.Rectangle, text_left: str, text_right: str, value: float, min_value: float, max_value: float) -> float
# Slider control, returns selected value
def gui_slider_bar(bounds: raylib.Rectangle, text_left: str, text_right: str, value: float, min_value: float, max_value: float) -> float
# Slider Bar control, returns selected value
def gui_spinner(bounds: raylib.Rectangle, text: str, value: Ptr[libs.c.CInt], min_value: int, max_value: int, edit_mode: bool) -> bool
# Spinner control, returns selected value
def gui_status_bar(bounds: raylib.Rectangle, text: str) -> None
# Status Bar control, shows info text
def gui_style_prop(control_id: int, property_id: int, property_value: u32) -> GuiStyleProp
# Factory function for: GuiStyleProp
def gui_tab_bar(bounds: raylib.Rectangle, text: Ptr[Ptr[Const[libs.c.CChar]]], count: int, active: Ptr[libs.c.CInt]) -> int
# Tab Bar control, returns TAB to be closed or -1
def gui_text_box(bounds: raylib.Rectangle, text: str, text_size: int, edit_mode: bool) -> bool
# Text Box control, updates input text
def gui_text_box_multi(bounds: raylib.Rectangle, text: str, text_size: int, edit_mode: bool) -> bool
# Text Box control with multiple lines
def gui_text_input_box(bounds: raylib.Rectangle, title: str, message: str, buttons: str, text: str, text_max_size: int, secret_view_active: Ptr[libs.c.CInt]) -> int
# Text Input Box control, ask for text, supports secret
def gui_toggle(bounds: raylib.Rectangle, text: str, active: bool) -> bool
# Toggle Button control, returns true when active
def gui_toggle_group(bounds: raylib.Rectangle, text: str, active: int) -> int
# Toggle Group control, returns active toggle index
def gui_unlock() -> None
# Unlock gui controls (global state)
def gui_value_box(bounds: raylib.Rectangle, text: str, value: Ptr[libs.c.CInt], min_value: int, max_value: int, edit_mode: bool) -> bool
# Value Box control, updates input text with numbers
def gui_window_box(bounds: raylib.Rectangle, title: str) -> bool
# Window Box control, shows a window that can be closed


# --------------------------------------------------
## raylib.math
# --------------------------------------------------
class float16
class float3
# NOTE: Helper types to be used instead of array return types for *ToFloat functions
def clamp(value: float, min: float, max: float) -> float
def float_equals(x: float, y: float) -> int
def lerp(start: float, end: float, amount: float) -> float
def matrix_add(left: raylib.Matrix, right: raylib.Matrix) -> raylib.Matrix
def matrix_determinant(mat: raylib.Matrix) -> float
def matrix_frustum(left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64) -> raylib.Matrix
def matrix_identity() -> raylib.Matrix
def matrix_invert(mat: raylib.Matrix) -> raylib.Matrix
def matrix_look_at(eye: raylib.Vector3, target: raylib.Vector3, up: raylib.Vector3) -> raylib.Matrix
def matrix_multiply(left: raylib.Matrix, right: raylib.Matrix) -> raylib.Matrix
def matrix_ortho(left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64) -> raylib.Matrix
def matrix_perspective(fovy: f64, aspect: f64, near: f64, far: f64) -> raylib.Matrix
def matrix_rotate(axis: raylib.Vector3, angle: float) -> raylib.Matrix
def matrix_rotate_x(angle: float) -> raylib.Matrix
def matrix_rotate_xyz(angle: raylib.Vector3) -> raylib.Matrix
def matrix_rotate_y(angle: float) -> raylib.Matrix
def matrix_rotate_z(angle: float) -> raylib.Matrix
def matrix_rotate_zyx(angle: raylib.Vector3) -> raylib.Matrix
def matrix_scale(x: float, y: float, z: float) -> raylib.Matrix
def matrix_subtract(left: raylib.Matrix, right: raylib.Matrix) -> raylib.Matrix
def matrix_to_float_v(mat: raylib.Matrix) -> raylib.float16
def matrix_trace(mat: raylib.Matrix) -> float
def matrix_translate(x: float, y: float, z: float) -> raylib.Matrix
def matrix_transpose(mat: raylib.Matrix) -> raylib.Matrix
def normalize(value: float, start: float, end: float) -> float
def quaternion_add(q1: raylib.Quaternion, q2: raylib.Quaternion) -> raylib.Quaternion
def quaternion_add_value(q: raylib.Quaternion, add: float) -> raylib.Quaternion
def quaternion_divide(q1: raylib.Quaternion, q2: raylib.Quaternion) -> raylib.Quaternion
def quaternion_equals(p: raylib.Quaternion, q: raylib.Quaternion) -> int
def quaternion_from_axis_angle(axis: raylib.Vector3, angle: float) -> raylib.Quaternion
def quaternion_from_euler(pitch: float, yaw: float, roll: float) -> raylib.Quaternion
def quaternion_from_matrix(mat: raylib.Matrix) -> raylib.Quaternion
def quaternion_from_vector3_to_vector3(p_from: raylib.Vector3, to: raylib.Vector3) -> raylib.Quaternion
def quaternion_identity() -> raylib.Quaternion
def quaternion_invert(q: raylib.Quaternion) -> raylib.Quaternion
def quaternion_length(q: raylib.Quaternion) -> float
def quaternion_lerp(q1: raylib.Quaternion, q2: raylib.Quaternion, amount: float) -> raylib.Quaternion
def quaternion_multiply(q1: raylib.Quaternion, q2: raylib.Quaternion) -> raylib.Quaternion
def quaternion_nlerp(q1: raylib.Quaternion, q2: raylib.Quaternion, amount: float) -> raylib.Quaternion
def quaternion_normalize(q: raylib.Quaternion) -> raylib.Quaternion
def quaternion_scale(q: raylib.Quaternion, mul: float) -> raylib.Quaternion
def quaternion_slerp(q1: raylib.Quaternion, q2: raylib.Quaternion, amount: float) -> raylib.Quaternion
def quaternion_subtract(q1: raylib.Quaternion, q2: raylib.Quaternion) -> raylib.Quaternion
def quaternion_subtract_value(q: raylib.Quaternion, sub: float) -> raylib.Quaternion
def quaternion_to_axis_angle(q: raylib.Quaternion, out_axis: Ptr[raylib.Vector3], out_angle: Ptr[libs.c.CFloat]) -> None
def quaternion_to_euler(q: raylib.Quaternion) -> raylib.Vector3
def quaternion_to_matrix(q: raylib.Quaternion) -> raylib.Matrix
def quaternion_transform(q: raylib.Quaternion, mat: raylib.Matrix) -> raylib.Quaternion
def remap(value: float, input_start: float, input_end: float, output_start: float, output_end: float) -> float
def vector2_add(v1: raylib.Vector2, v2: raylib.Vector2) -> raylib.Vector2
def vector2_add_value(v: raylib.Vector2, add: float) -> raylib.Vector2
def vector2_angle(v1: raylib.Vector2, v2: raylib.Vector2) -> float
def vector2_clamp(v: raylib.Vector2, min: raylib.Vector2, max: raylib.Vector2) -> raylib.Vector2
def vector2_clamp_value(v: raylib.Vector2, min: float, max: float) -> raylib.Vector2
def vector2_distance(v1: raylib.Vector2, v2: raylib.Vector2) -> float
def vector2_distance_sqr(v1: raylib.Vector2, v2: raylib.Vector2) -> float
def vector2_divide(v1: raylib.Vector2, v2: raylib.Vector2) -> raylib.Vector2
def vector2_dot_product(v1: raylib.Vector2, v2: raylib.Vector2) -> float
def vector2_equals(p: raylib.Vector2, q: raylib.Vector2) -> int
def vector2_invert(v: raylib.Vector2) -> raylib.Vector2
def vector2_length(v: raylib.Vector2) -> float
def vector2_length_sqr(v: raylib.Vector2) -> float
def vector2_lerp(v1: raylib.Vector2, v2: raylib.Vector2, amount: float) -> raylib.Vector2
def vector2_line_angle(start: raylib.Vector2, end: raylib.Vector2) -> float
def vector2_move_towards(v: raylib.Vector2, target: raylib.Vector2, max_distance: float) -> raylib.Vector2
def vector2_multiply(v1: raylib.Vector2, v2: raylib.Vector2) -> raylib.Vector2
def vector2_negate(v: raylib.Vector2) -> raylib.Vector2
def vector2_normalize(v: raylib.Vector2) -> raylib.Vector2
def vector2_one() -> raylib.Vector2
def vector2_reflect(v: raylib.Vector2, normal: raylib.Vector2) -> raylib.Vector2
def vector2_rotate(v: raylib.Vector2, angle: float) -> raylib.Vector2
def vector2_scale(v: raylib.Vector2, scale: float) -> raylib.Vector2
def vector2_subtract(v1: raylib.Vector2, v2: raylib.Vector2) -> raylib.Vector2
def vector2_subtract_value(v: raylib.Vector2, sub: float) -> raylib.Vector2
def vector2_transform(v: raylib.Vector2, mat: raylib.Matrix) -> raylib.Vector2
def vector2_zero() -> raylib.Vector2
def vector3_add(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_add_value(v: raylib.Vector3, add: float) -> raylib.Vector3
def vector3_angle(v1: raylib.Vector3, v2: raylib.Vector3) -> float
def vector3_barycenter(p: raylib.Vector3, a: raylib.Vector3, b: raylib.Vector3, c_arg: raylib.Vector3) -> raylib.Vector3
def vector3_clamp(v: raylib.Vector3, min: raylib.Vector3, max: raylib.Vector3) -> raylib.Vector3
def vector3_clamp_value(v: raylib.Vector3, min: float, max: float) -> raylib.Vector3
def vector3_cross_product(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_distance(v1: raylib.Vector3, v2: raylib.Vector3) -> float
def vector3_distance_sqr(v1: raylib.Vector3, v2: raylib.Vector3) -> float
def vector3_divide(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_dot_product(v1: raylib.Vector3, v2: raylib.Vector3) -> float
def vector3_equals(p: raylib.Vector3, q: raylib.Vector3) -> int
def vector3_invert(v: raylib.Vector3) -> raylib.Vector3
def vector3_length(v: Const[raylib.Vector3]) -> float
def vector3_length_sqr(v: Const[raylib.Vector3]) -> float
def vector3_lerp(v1: raylib.Vector3, v2: raylib.Vector3, amount: float) -> raylib.Vector3
def vector3_max(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_min(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_multiply(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_negate(v: raylib.Vector3) -> raylib.Vector3
def vector3_normalize(v: raylib.Vector3) -> raylib.Vector3
def vector3_one() -> raylib.Vector3
def vector3_ortho_normalize(v1: Ptr[raylib.Vector3], v2: Ptr[raylib.Vector3]) -> None
def vector3_perpendicular(v: raylib.Vector3) -> raylib.Vector3
def vector3_reflect(v: raylib.Vector3, normal: raylib.Vector3) -> raylib.Vector3
def vector3_refract(v: raylib.Vector3, n: raylib.Vector3, r: float) -> raylib.Vector3
def vector3_rotate_by_axis_angle(v: raylib.Vector3, axis: raylib.Vector3, angle: float) -> raylib.Vector3
def vector3_rotate_by_quaternion(v: raylib.Vector3, q: raylib.Quaternion) -> raylib.Vector3
def vector3_scale(v: raylib.Vector3, scalar: float) -> raylib.Vector3
def vector3_subtract(v1: raylib.Vector3, v2: raylib.Vector3) -> raylib.Vector3
def vector3_subtract_value(v: raylib.Vector3, sub: float) -> raylib.Vector3
def vector3_to_float_v(v: raylib.Vector3) -> raylib.float3
def vector3_transform(v: raylib.Vector3, mat: raylib.Matrix) -> raylib.Vector3
def vector3_unproject(source: raylib.Vector3, projection: raylib.Matrix, view: raylib.Matrix) -> raylib.Vector3
def vector3_zero() -> raylib.Vector3
def wrap(value: float, min: float, max: float) -> float


# --------------------------------------------------
## raylib.utils
# --------------------------------------------------
class Data
# Arbitary data (void*)
def clear() -> None
# Clear background with RAYWHITE colour
def cos_deg(x: float) -> float
def is_desktop() -> bool
# Are we running in raylib in desktop?
def is_hot_reload() -> bool
# Are we running in raylib with hot reload?
def is_web() -> bool
# Are we running in raylib WASM/Web?
def lerp_color(a: raylib.Color, b: raylib.Color, fraction: float) -> raylib.Color
def pi() -> float
# Get approximate PI value
def remap(x: float, a: float, b: float, c: float, d: float) -> float
# Map x to be from 'a to b' range to 'c to d' range
def run_game_loop(fps: int, data: Data) -> int
# Run def game_step(d: utils.Data) in a loop
# Warning! this assumes you have def game_step(d: utils.Data) present in code
# Warning! game_step def must be present in same file as main()
# See wind_tree_gs.yaka for a sample of how to use this.
# Use only if you run into slowness with standard while loop
def sin_deg(x: float) -> float
def tan_deg(x: float) -> float
def todeg(radians: float) -> float
def torad(degrees: float) -> float


# --------------------------------------------------
## w4
# --------------------------------------------------
BLIT_1BPP: Const[u32]
BLIT_2BPP: Const[u32]
BLIT_FLIP_X: Const[u32]
BLIT_FLIP_Y: Const[u32]
BLIT_ROTATE: Const[u32]
BUTTON_1: Const[u8]
BUTTON_2: Const[u8]
BUTTON_DOWN: Const[u8]
BUTTON_LEFT: Const[u8]
BUTTON_RIGHT: Const[u8]
BUTTON_UP: Const[u8]
MOUSE_LEFT: Const[u8]
MOUSE_MIDDLE: Const[u8]
MOUSE_RIGHT: Const[u8]
SCREEN_SIZE: Const[int]
# Screen size of wasm4 console
SYSTEM_HIDE_GAMEPAD_OVERLAY: Const[u8]
SYSTEM_PRESERVE_FRAMEBUFFER: Const[u8]
TONE_MODE1: Const[u32]
TONE_MODE2: Const[u32]
TONE_MODE3: Const[u32]
TONE_MODE4: Const[u32]
TONE_NOISE: Const[u32]
TONE_PAN_LEFT: Const[u32]
TONE_PAN_RIGHT: Const[u32]
TONE_PULSE1: Const[u32]
TONE_PULSE2: Const[u32]
TONE_TRIANGLE: Const[u32]
def blit(data: Ptr[Const[u8]], x: int, y: int, width: u32, height: u32, flags: u32) -> None
# Copies pixels to the framebuffer
def blit_sub(data: Ptr[Const[u8]], x: int, y: int, width: u32, height: u32, src_x: u32, src_y: u32, stride: u32, flags: u32) -> None
# Copies a subregion within a larger sprite atlas to the framebuffer
def diskr(dest: AnyPtr, size: u32) -> u32
# Reads up to `size` bytes from persistent storage into the pointer `dest`
def diskw(src: AnyPtrToConst, size: u32) -> u32
# Writes up to `size` bytes from the pointer `src` into persistent storage
def draw_colors() -> u16
# Read draw colors
def framebuffer() -> Ptr[u8]
# Access pointer to framebuffer
def gamepad1() -> u8
# Read gamepad 1 value
def gamepad2() -> u8
# Read gamepad 2 value
def gamepad3() -> u8
# Read gamepad 3 value
def gamepad4() -> u8
# Read gamepad 4 value
def hline(x: int, y: int, length: u32) -> None
# Draws a horizontal line
def line(x1: int, y1: int, x2: int, y2: int) -> None
# Draws a line between two points
def mouse_buttons() -> u8
# Read mouse buttons
def mouse_x() -> i16
# Read mouse x
def mouse_y() -> i16
# Read mouse y
def netplay() -> int
def oval(x: int, y: int, width: u32, height: u32) -> None
# Draws an oval (or circle)
def palette() -> Ptr[u32]
# Get a pointer to pallet
def rect(x: int, y: int, width: u32, height: u32) -> None
# Draws a rectangle
def set_draw_colors(value: u16) -> None
# Set draw colors
def set_game_state(data: AnyPtr) -> None
# Set a state value to be passed to game_step() function
def set_palette(c1: u32, c2: u32, c3: u32, c4: u32) -> None
# Set palette
def set_system_flags(value: u8) -> None
# Set system flags
def system_flags() -> u8
# Read system flags
def text(text_data: str, x: int, y: int) -> None
# Draws text using the built-in system font
def text_u8(text_data: Ptr[Const[u8]], x: int, y: int) -> None
# Draws text from given binarydata("text") (or manually created u8 Ptr) (no string allocation)
def tone(frequency: u32, duration: u32, volume: u32, flags: u32) -> None
# Plays a sound tone
def trace(text_data: str) -> None
# Prints a message to the debug console
def trace_u8(text_data: Ptr[Const[u8]]) -> None
# Prints a message to the debug console from given binarydata("text") (or manually created u8 Ptr) (no string allocation)
def vline(x: int, y: int, length: u32) -> None
# Draws a vertical line

